'use strict';

/**
 * @name accept terms and conditions module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.accept-terms-and-conditions', ['binary.pages.accept-terms-and-conditions.controllers', 'binary.pages.accept-terms-and-conditions.directives']);

    angular.module('binary.pages.accept-terms-and-conditions.controllers', []);

    angular.module('binary.pages.accept-terms-and-conditions.directives', []);
})();
'use strict';

/**
 * @name help module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.pages.help', ['binary.pages.help.controllers']);

  angular.module('binary.pages.help.controllers', []);
})();
'use strict';

/**
 * @name Home Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/10/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.home', ['binary.pages.home.controllers']);

  angular.module('binary.pages.home.controllers', []);
})();
'use strict';

/**
 * @name new-real-account-opening module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.new-real-account-opening', ['binary.pages.new-real-account-opening.controllers', 'binary.pages.new-real-account-opening.components']);

  angular.module('binary.pages.new-real-account-opening.controllers', []);

  angular.module('binary.pages.new-real-account-opening.components', ['binary.pages.new-real-account-opening.components.new-account-maltainvest', 'binary.pages.new-real-account-opening.components.new-account-real']);
})();
'use strict';

/**
 * @name Profile Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 11/21/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.profile', ['binary.pages.profile.controllers']);

  angular.module('binary.pages.profile.controllers', []);
})();
'use strict';

/**
 * @name profit-table module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.profit-table', ['binary.pages.profit-table.controllers', 'binary.pages.profit-table.directives', 'binary.pages.profit-table.filters']);

    angular.module('binary.pages.profit-table.controllers', []);

    angular.module('binary.pages.profit-table.directives', []);

    angular.module('binary.pages.profit-table.filters', []);
})();
'use strict';

/**
 * @name self-exclusion module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/12/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.self-exclusion', ['binary.pages.self-exclusion.controllers']);

  angular.module('binary.pages.self-exclusion.controllers', []);
})();
'use strict';

/**
 * @name settings module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/11/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.settings', ['binary.pages.settings.controllers']);

  angular.module('binary.pages.settings.controllers', []);
})();
'use strict';

/**
 * @name Singin Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/10/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.signin', ['binary.pages.signin.components', 'binary.pages.signin.controllers']);

  angular.module('binary.pages.signin.controllers', []);

  angular.module('binary.pages.signin.components', ['binary.pages.signin.components.oauth']);
})();
'use strict';

/**
 * @name statement module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.statement', ['binary.pages.statement.controllers', 'binary.pages.statement.directives', 'binary.pages.statement.filters']);

    angular.module('binary.pages.statement.controllers', []);

    angular.module('binary.pages.statement.directives', []);

    angular.module('binary.pages.statement.filters', []);
})();
'use strict';

/**
 * @name terms and conditions module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.terms-and-conditions', ['binary.pages.terms-and-conditions.controllers', 'binary.pages.terms-and-conditions.directives']);

    angular.module('binary.pages.terms-and-conditions.controllers', []);

    angular.module('binary.pages.terms-and-conditions.directives', []);
})();
'use strict';

/**
 * @name options controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade', ['binary.pages.trade.components', 'binary.pages.trade.controllers', 'binary.pages.trade.services']);

    angular.module('binary.pages.trade.components', ['binary.pages.trade.components.options', 'binary.pages.trade.components.chart', 'binary.pages.trade.components.payout', 'binary.pages.trade.components.purchase', 'binary.pages.trade.components.longcode']);

    angular.module('binary.pages.trade.controllers', []);

    angular.module('binary.pages.trade.services', []);
})();
'use strict';

/**
 * @name transaction-detail module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.transaction-detail', ['binary.pages.transaction-detail.controllers', 'binary.pages.transaction-detail.directives']);

    angular.module('binary.pages.transaction-detail.controllers', []);

    angular.module('binary.pages.transaction-detail.directives', []);
})();
'use strict';

/**
 * @name update module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/26/2015
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.update', ['binary.pages.update.controllers']);

  angular.module('binary.pages.update.controllers', []);
})();
'use strict';

/**
 * @name accounts module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.accounts', ['binary.share.components.accounts.controllers', 'binary.share.components.accounts.directives']);

  angular.module('binary.share.components.accounts.controllers', []);

  angular.module('binary.share.components.accounts.directives', []);
})();
'use strict';

/**
 * @name app version module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.app-version', ['binary.share.components.app-version.controllers', 'binary.share.components.app-version.directives']);

    angular.module('binary.share.components.app-version.controllers', []);

    angular.module('binary.share.components.app-version.directives', []);
})();
'use strict';

/**
 * @name balance module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.balance', ['binary.share.components.balance.directives', 'binary.share.components.balance.controllers']);

  angular.module('binary.share.components.balance.controllers', []);

  angular.module('binary.share.components.balance.directives', []);
})();
'use strict';

/**
 * @name Connectivity Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/22/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.connectivity', ['binary.share.components.connectivity.controllers', 'binary.share.components.connectivity.directives']);

  angular.module('binary.share.components.connectivity.controllers', []);

  angular.module('binary.share.components.connectivity.directives', []);
})();
'use strict';

/**
 * @name language module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.share.components.language', ['binary.share.components.language.directives', 'binary.share.components.language.controllers']);

  angular.module('binary.share.components.language.directives', []);

  angular.module('binary.share.components.language.controllers', []);
})();
'use strict';

/**
 * @name logout module
 * @author
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.logout', ['binary.share.components.logout.controllers', 'binary.share.components.logout.directives']);

    angular.module('binary.share.components.logout.controllers', []);

    angular.module('binary.share.components.logout.directives', []);
})();
'use strict';

/**
 * @name long-press module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/05/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.long-press', ['binary.share.components.long-press.directives']);

  angular.module('binary.share.components.long-press.directives', []);
})();
'use strict';

/**
 * @name number Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/02/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.number', ['binary.share.components.number.directives']);

  angular.module('binary.share.components.number.directives', []);
})();
'use strict';

/**
 * @name ping module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.share.components.ping', ['binary.share.components.ping.controllers', 'binary.share.components.ping.directives']);

  angular.module('binary.share.components.ping.controllers', []);

  angular.module('binary.share.components.ping.directives', []);
})();
'use strict';

/**
 * @name real-account-opening module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.real-account-opening', ['binary.share.components.real-account-opening.controllers', 'binary.share.components.real-account-opening.directives']);

    angular.module('binary.share.components.real-account-opening.controllers', []);

    angular.module('binary.share.components.real-account-opening.directives', []);
})();
'use strict';

/**
 * @name reality-check module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.reality-check', ['binary.share.components.reality-check.controllers', 'binary.share.components.reality-check.directives']);

    angular.module('binary.share.components.reality-check.controllers', []);

    angular.module('binary.share.components.reality-check.directives', []);
})();
'use strict';

/**
 * @name Regex Validate Module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/02/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.regex-validate', ['binary.share.components.regex-validate.directives']);

  angular.module('binary.share.components.regex-validate.directives', []);
})();
'use strict';

/**
 * @name spinner-logo module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.spinner-logo', ['binary.share.components.spinner-logo.directives', 'binary.share.components.spinner-logo.controllers']);

  angular.module('binary.share.components.spinner-logo.directives', []);

  angular.module('binary.share.components.spinner-logo.controllers', []);
})();
'use strict';

/**
 * @name updater module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/20/2015
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.updater', ['binary.share.components.updater.controllers', 'binary.share.components.updater.directives']);

  angular.module('binary.share.components.updater.controllers', []);

  angular.module('binary.share.components.updater.directives', []);
})();
'use strict';

/**
 * @name new-account-maltainvest module
 * @author Nazanin Reihanib Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict', angular.module('binary.pages.new-real-account-opening.components.new-account-maltainvest', []);
})();
'use strict';

/**
 * @name new-account-real module
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict', angular.module('binary.pages.new-real-account-opening.components.new-account-real', []);
})();
'use strict';

/**
 * @name Oauth module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/13/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict', angular.module('binary.pages.signin.components.oauth', []);
})();
'use strict';

/**
 * @name chart module
 * @author morteza tavnarad
 * @contributors []
 * @since 08/29/2016
 * @copyright binary ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.chart', ['binary.pages.trade.components.chart.controllers', 'binary.pages.trade.components.chart.directives', 'binary.pages.trade.components.chart.services']);

    angular.module('binary.pages.trade.components.chart.controllers', []);

    angular.module('binary.pages.trade.components.chart.directives', []);

    angular.module('binary.pages.trade.components.chart.services', []);
})();
'use strict';

/**
 * @name longcode module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/22/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.longcode', ['binary.pages.trade.components.longcode.controllers', 'binary.pages.trade.components.longcode.directives']);

  angular.module('binary.pages.trade.components.longcode.controllers', []);

  angular.module('binary.pages.trade.components.longcode.directives', []);
})();
'use strict';

/**
 * @name options module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options', ['binary.pages.trade.components.options.controllers', 'binary.pages.trade.components.options.directives', 'binary.pages.trade.components.options.services']);

  angular.module('binary.pages.trade.components.options.controllers', []);

  angular.module('binary.pages.trade.components.options.directives', []);

  angular.module('binary.pages.trade.components.options.services', []);
})();
'use strict';

/**
 * @name payout module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.payout', ['binary.pages.trade.components.payout.controllers', 'binary.pages.trade.components.payout.directives']);

    angular.module('binary.pages.trade.components.payout.controllers', []);

    angular.module('binary.pages.trade.components.payout.directives', []);
})();
'use strict';

/**
 * @name purchase module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.purchase', ['binary.pages.trade.components.purchase.controllers', 'binary.pages.trade.components.purchase.directives']);

    angular.module('binary.pages.trade.components.purchase.controllers', []);

    angular.module('binary.pages.trade.components.purchase.directives', []);
})();
'use strict';

// Ionic Starter App

// angular.module is a global place for creating, registering and retrieving Angular modules
// 'starter' is the name of this angular module example (also set in a <body> attribute in index.html)
// the 2nd parameter is an array of 'requires'

(function () {
    'use restrict';

    angular.module('binary', ['ionic', 'pascalprecht.translate', 'hmTouchEvents', 'ngIOS9UIWebViewPatch', 'binary.share.components', 'binary.share.services', 'binary.pages', 'ngMessages', 'ngCordova']);

    angular.module('binary.share.components', ['binary.share.components.language', 'binary.share.components.ping', 'binary.share.components.accounts', 'binary.share.components.spinner-logo', 'binary.share.components.balance', 'binary.share.components.long-press', 'binary.share.components.reality-check', 'binary.share.components.real-account-opening', 'binary.share.components.logout', 'binary.share.components.connectivity', 'binary.share.components.regex-validate', 'binary.share.components.number', 'binary.share.components.app-version', 'binary.share.components.updater']);

    angular.module('binary.share.services', []);

    angular.module('binary.pages', ['binary.pages.home', 'binary.pages.signin', 'binary.pages.help', 'binary.pages.trade', 'binary.pages.new-real-account-opening', 'binary.pages.profit-table', 'binary.pages.statement', 'binary.pages.transaction-detail', 'binary.pages.settings', 'binary.pages.self-exclusion', 'binary.pages.profile', 'binary.pages.terms-and-conditions', 'binary.pages.accept-terms-and-conditions', 'binary.pages.update']);

    String.prototype.capitalize = function () {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };
})();
'use strict';

(function () {
  'use strict';

  angular.module('binary').run(["$rootScope", "$ionicPlatform", "$state", "alertService", "appStateService", function ($rootScope, $ionicPlatform, $state, alertService, appStateService) {
    $ionicPlatform.ready(function () {

      if (window.cordova && window.cordova.plugins.backgroundMode) {
        cordova.plugins.backgroundMode.setDefaults({
          title: 'Binary.com TickTrade',
          text: '',
          ticker: 'TickTrade is running in background',
          color: '#2A3052'
        });
        cordova.plugins.backgroundMode.enable();
      }

      if (typeof window.ga != "undefined") {
        window.ga.startTrackerWithId("UA-40877026-7");
      } else {
        console.log('Google Analytics is unavailable');
      }

      if (window.cordova && window.cordova.plugins.Keyboard) {
        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
        // for form inputs)
        cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);

        // Don't remove this line unless you know what you are doing. It stops the viewport
        // from snapping when text inputs are focused. Ionic handles this internally for
        // a much nicer keyboard experience.
        cordova.plugins.Keyboard.disableScroll(true);
      }
      if (window.StatusBar) {
        StatusBar.styleDefault();
      }

      // Handle the android's hardware button
      $ionicPlatform.registerBackButtonAction(function () {
        if (appStateService.isPopupOpen) {
          return;
        } else {
          if (["signin", "home", "update"].indexOf($state.current.name) > -1) {
            navigator.app.exitApp();
          } else if ($state.current.name === "trade" && appStateService.purchaseMode) {
            return;
          } else if ($state.current.name === "trade" && !appStateService.purchaseMode && !appStateService.tradeMode) {
            appStateService.tradeMode = true;
            $rootScope.$broadcast('appState:tradeMode');
            if (!$rootScope.$$phase) {
              $rootScope.$apply();
            }
          } else if (['trade', 'profittable', 'statement'].indexOf($state.current.name) > -1) {
            alertService.confirmExit(function (res) {
              if (res == 1) {
                sessionStorage.removeItem('start');
                sessionStorage.removeItem('_interval');
                navigator.app.exitApp();
              }
            });
          } else {
            $state.goBack();
          }
        }
      }, 500);
    });
  }]);
})();
'use strict';

/**
 * ==================  angular-ios9-uiwebview.patch.js v1.1.1 ==================
 *
 * This patch works around iOS9 UIWebView regression that causes infinite digest
 * errors in Angular.
 *
 * The patch can be applied to Angular 1.2.0 – 1.4.5. Newer versions of Angular
 * have the workaround baked in.
 *
 * To apply this patch load/bundle this file with your application and add a
 * dependency on the "ngIOS9UIWebViewPatch" module to your main app module.
 *
 * For example:
 *
 * ```
 * angular.module('myApp', ['ngRoute'])`
 * ```
 *
 * becomes
 *
 * ```
 * angular.module('myApp', ['ngRoute', 'ngIOS9UIWebViewPatch'])
 * ```
 *
 *
 * More info:
 * - https://openradar.appspot.com/22186109
 * - https://github.com/angular/angular.js/issues/12241
 * - https://github.com/driftyco/ionic/issues/4082
 *
 *
 * @license AngularJS
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */

angular.module('ngIOS9UIWebViewPatch', ['ng']).config(['$provide', function ($provide) {
  'use strict';

  $provide.decorator('$browser', ['$delegate', '$window', function ($delegate, $window) {

    if (isIOS9UIWebView($window.navigator.userAgent)) {
      return applyIOS9Shim($delegate);
    }

    return $delegate;

    function isIOS9UIWebView(userAgent) {
      return (/(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent)
      );
    }

    function applyIOS9Shim(browser) {
      var pendingLocationUrl = null;
      var originalUrlFn = browser.url;

      browser.url = function () {
        if (arguments.length) {
          pendingLocationUrl = arguments[0];
          return originalUrlFn.apply(browser, arguments);
        }

        return pendingLocationUrl || originalUrlFn.apply(browser, arguments);
      };

      window.addEventListener('popstate', clearPendingLocationUrl, false);
      window.addEventListener('hashchange', clearPendingLocationUrl, false);

      function clearPendingLocationUrl() {
        pendingLocationUrl = null;
      }

      return browser;
    }
  }]);
}]);
'use strict';

/**
 * @contributors []
 * @since 10/25/2015
 * @copyright Binary Ltd
 */

angular.module('binary').constant('config', {
												'app_id': "10",
												'wsUrl': 'wss://ws.binaryws.com/websockets/v3', // Don't set language value here
												'oauthUrl': 'https://oauth.binary.com/oauth2/authorize',
												'tradeCategories': [{
																								name: "up_down",
																								markets: ['forex', 'volidx', 'random'],
																								value: "UP/DOWN"
												}, {
																								name: "digit_matches_differs",
																								value: "MATCH/DIFF",
																								markets: ['volidx', 'random'],
																								digits: true
												}, {
																								name: "digit_even_odd",
																								markets: ['volidx', 'random'],
																								value: "EVEN/ODD"
												}, {
																								name: "digit_over_under",
																								value: "OVER/UNDER",
																								markets: ['volidx', 'random'],
																								digits: true
												}, {
																								name: "asians",
																								value: "Asians",
																								markets: ['volidx', 'random']
												}],
												'tradeTypes': [{
																								name: 'Up',
																								value: 'CALL',
																								digits: false,
																								category: "UP/DOWN"
												}, {
																								name: 'Down',
																								value: 'PUT',
																								digits: false,
																								category: "UP/DOWN"

												}, {
																								name: 'Asians Up',
																								value: 'ASIANU',
																								digits: false,
																								category: "Asians"

												}, {
																								name: 'Asians Down',
																								value: 'ASIAND',
																								digits: false,
																								category: "Asians"

												}, {
																								name: 'Digit Match',
																								value: 'DIGITMATCH',
																								digits: true,
																								category: "MATCH/DIFF"

												}, {
																								name: 'Digit Differs',
																								value: 'DIGITDIFF',
																								digits: true,
																								category: "MATCH/DIFF"

												}, {
																								name: 'Digit Even',
																								value: 'DIGITEVEN',
																								category: "EVEN/ODD"

												}, {
																								name: 'Digit Odd',
																								value: 'DIGITODD',
																								category: "EVEN/ODD"

												}, {
																								name: 'Digit Over',
																								value: 'DIGITOVER',
																								digits: true,
																								category: "OVER/UNDER"

												}, {
																								name: 'Digit Under',
																								value: 'DIGITUNDER',
																								digits: true,
																								category: "OVER/UNDER"

												}],
												'language': 'en',
												'assetIndexes': {
																								symbol: 0,
																								displayName: 1,
																								contracts: 2,
																								contractName: 0,
																								contractDisplayName: 1,
																								contractFrom: 2,
																								contractTo: 3
												},
												'appSupportedLanguages': ['en', 'id', 'ru', 'zh_tw', 'zh_cn', 'de']
});
'use strict';

/**
 * @name currency filter decorator
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/21/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary').config(Currency);

  Currency.$inject = ['$provide'];

  function Currency($provide) {
    $provide.decorator('currencyFilter', ['$delegate', function ($delegate) {
      var srcFilter = $delegate;

      var extendsFilter = function extendsFilter() {
        var locale = (localStorage.language || "en").replace('_', '-');
        var currency = arguments[1] || 'USD';
        return formatMoney(locale, currency, arguments[0]);
      };

      function formatMoney(locale, currency, value) {
        return Intl.NumberFormat(locale, {
          style: 'currency',
          currency: currency || 'USD'
        }).format(value);
      }
      var format_money = {
        "USD": "$",
        "GBP": "£",
        "AUD": "A$",
        "EUR": "€",
        "JPY": "¥"
      };
      return extendsFilter;
    }]);
  }
})();
'use strict';

/**
 * @name angular-ui $state decorator
 * @author Morteza Tavanarad
 * @contributors []
 * @since 11/07/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  StateDecorator.$inject = ["$provide"];
  angular.module('binary').config(StateDecorator);

  function StateDecorator($provide) {
    $provide.decorator('$state', ['$delegate', '$rootScope', function ($delegate, $rootScope) {
      var $state = $delegate;
      $state.previous = undefined;

      $state.goBack = function () {
        if ($state.previous) {
          $state.go($state.previous.name);
        }
      };

      $rootScope.$on('$stateChangeSuccess', function (e, to, toParams, from, fromParams) {
        $state.previous = {
          name: from,
          params: fromParams
        };
      });

      return $state;
    }]);
  }
})();
'use strict';

/**
 * @name states.config
 * @author Massih Hazrati
 * @contributors []
 * @since 11/4/2015
 * @copyright Binary Ltd
 */

angular.module('binary').config(["$stateProvider", "$urlRouterProvider", "$ionicConfigProvider", function ($stateProvider, $urlRouterProvider, $ionicConfigProvider) {
  $ionicConfigProvider.views.swipeBackEnabled(false);
  $stateProvider.state('home', {
    url: '/',
    cache: false,
    templateUrl: 'js/pages/home/home.template.html',
    controller: 'HomeController'
  }).state('layout', {
    cache: false,
    templateUrl: 'js/share/templates/layout/main-layout.template.html',
    abstract: true
  }).state('trade', {
    parent: 'layout',
    cache: false,
    controller: 'TradeController',
    controllerAs: 'vm',
    templateUrl: 'js/pages/trade/trade.template.html'
  }).state('signin', {
    cache: false,
    templateUrl: 'js/pages/sign-in/sign-in.template.html',
    controller: 'SigninController',
    controllerAs: 'vm'
  }).state('help', {
    templateUrl: 'js/pages/help/help.template.html',
    controller: 'HelpController',
    controllerAs: 'vm'
  }).state('profittable', {
    parent: 'layout',
    cache: true,
    templateUrl: 'js/pages/profit-table/profit-table.template.html',
    controller: 'ProfitTableController',
    controllerAs: 'vm'
  }).state('statement', {
    parent: 'layout',
    cache: true,
    templateUrl: 'js/pages/statement/statement.template.html',
    controller: 'StatementController',
    controllerAs: 'vm'
  }).state('transactiondetail', {
    parent: 'layout',
    cache: false,
    templateUrl: 'js/pages/transaction-detail/transaction-detail.template.html',
    controller: 'TransactionDetailController',
    controllerAs: 'vm',
    reloadOnSearch: false
  }).state('realaccountopening', {
    parent: 'layout',
    cache: false,
    templateUrl: 'js/pages/new-real-account-opening/new-real-account-opening.template.html',
    controller: 'NewRealAccountOpeningController',
    controllerAs: 'vm'
  }).state('language', {
    parent: 'layout',
    cache: false,
    templateUrl: 'js/pages/language/language.template.html'
  }).state('settings', {
    parent: 'layout',
    cache: false,
    templateUrl: 'js/pages/settings/settings.template.html',
    controller: 'SettingsController',
    controllerAs: 'vm'
  }).state('self-exclusion', {
    parent: 'layout',
    cache: false,
    templateUrl: 'js/pages/self-exclusion/self-exclusion.template.html',
    controller: 'SelfExclusionController',
    controllerAs: 'vm'
  }).state('no-connection', {
    templateUrl: 'js/share/components/connectivity/connectivity.template.html'
  }).state('profile', {
    parent: 'layout',
    cache: false,
    templateUrl: 'js/pages/profile/profile.template.html',
    controller: 'ProfileController',
    controllerAs: 'vm'
  }).state('acceptTermsAndConditions', {
    parent: 'layout',
    cache: false,
    templateUrl: 'js/pages/accept-terms-and-conditions/accept-terms-and-conditions.template.html',
    controller: 'AcceptTermsAndConditionsController',
    controllerAs: 'vm'
  }).state('update', {
    url: '/update',
    cache: false,
    templateUrl: 'js/pages/update/update.template.html',
    controller: 'UpdateController',
    controllerAs: 'vm'
  });

  $urlRouterProvider.otherwise('/');
}]);
'use strict';

/**
 * @name translation.config
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/7/2016
 * @copyright Binary Ltd
 */

angular.module('binary').config(['$translateProvider', function ($translateProvider) {
	var language = localStorage['language'] || 'en';
	$translateProvider.preferredLanguage(language);
	$translateProvider.useStaticFilesLoader({
		prefix: 'i18n/',
		suffix: '.json'
	});
}]);
'use strict';

/**
 * @name accept terms and conditions controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.accept-terms-and-conditions.controllers').controller('AcceptTermsAndConditionsController', AcceptTermsAndConditions);

    AcceptTermsAndConditions.$inject = ['$scope', '$state', 'websocketService', 'alertService', 'appStateService'];

    function AcceptTermsAndConditions($scope, $state, websocketService, alertService, appStateService) {
        var vm = this;
        vm.data = {};
        vm.data.landingCompanyName = localStorage.getItem('landingCompanyName');
        vm.data.linkToTermAndConditions = "https://www.binary.com/" + (localStorage.getItem('language') || "en") + "/terms-and-conditions.html";

        vm.updateUserTermsAndConditions = function () {
            websocketService.sendRequestFor.TAndCApprovalSend();
        };

        vm.openTermsAndConditions = function () {
            window.open(vm.data.linkToTermAndConditions, '_blank');
        };

        $scope.$on('tnc_approval', function (e, tnc_approval) {
            if (tnc_approval == 1) {
                $state.go('trade');
            }
        });

        $scope.$on('tnc_approval:error', function (e, error) {
            alertService.displayError(error.message);
        });
    }
})();
'use strict';

/**
 * @name accept terms and conditions directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.accept-terms-and-conditions.directives').directive('bgAcceptTermsAndConditions', AcceptTermsAndConditions);

    function AcceptTermsAndConditions() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/accept-terms-and-conditions/accept-terms-and-conditions.template.html',
            controller: 'AcceptTermsAndConditionsController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name help module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.pages.help.controllers').controller('HelpController', Help);

  Help.$inject = ['$state', 'analyticsService', 'languageService'];

  function Help($state, analyticsService, languageService) {
    var vm = this;
    var language = languageService.read();
    vm.tokenUrl = "https://www.binary.com/" + language.toLowerCase() + "/user/settings/api_tokenws.html";

    analyticsService.google.trackView("Help");

    vm.backToSignInPage = function () {
      $state.go('signin');
    };

    vm.openExternal = function ($event) {
      window.open($event.currentTarget.href, "_system");
      return false;
    };
  }
})();
'use strict';

/**
 * @name HomeController
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/9/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.home.controllers').controller('HomeController', Home);

  Home.$inject = ['$scope', '$state', 'accountService', 'analyticsService', 'appStateService', 'websocketService'];

  function Home($scope, $state, accountService, analyticsService, appStateService, websocketService) {

    var vm = this;

    websocketService.sendRequestFor.websiteStatus();

    /**
     * wait untile authorization and decide
     * to redirect user  to the proper page
     */
    $scope.$on('authorize', function (e, response) {
      if (response) {
        $state.go('trade');
      } else {
        $state.go('signin');
      }
    });

    vm.init = function () {

      // send track view to Google Analytics
      analyticsService.google.trackView("Home");

      // Check that is saved any default account or not
      if (accountService.hasDefault()) {
        // Login to the server if there is any default account
        if (!appStateService.isLoggedin) {
          accountService.validate();
        } else {
          $state.go('trade');
        }
      } else {
        $state.go('signin');
      }
    };

    vm.init();
  }
})();
'use strict';

/**
 * @name new-real-account-opening controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.new-real-account-opening.controllers').controller('NewRealAccountOpeningController', NewRealAccountOpeningController);

  NewRealAccountOpeningController.$inject = ['$scope', 'appStateService'];

  function NewRealAccountOpeningController($scope, appStateService) {
    var vm = this;
    vm.isNewAccountReal = false;
    vm.isNewAccountMaltainvest = false;
    $scope.$applyAsync(function () {
      if (appStateService.isNewAccountReal) {
        vm.isNewAccountReal = true;
        vm.isNewAccountMaltainvest = false;
      }
      if (appStateService.isNewAccountMaltainvest) {
        vm.isNewAccountMaltainvest = true;
        vm.isNewAccountReal = false;
      }
    });
  }
})();
'use strict';

/**
 * @name Profile Module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 11/21/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.profile.controllers').controller('ProfileController', Profile);

  Profile.$inject = ['$scope', '$translate', 'alertService', 'appStateService', 'websocketService'];

  function Profile($scope, $translate, alertService, appStateService, websocketService) {
    var vm = this;
    vm.states = [];
    vm.disableUpdateButton = true;

    $scope.$on('get_settings', function (e, response) {
      $scope.$applyAsync(function () {
        vm.profile = response;
        if (vm.profile.date_of_birth) {
          vm.profile.date_of_birth = new Date(vm.profile.date_of_birth * 1000).toISOString('yyyy-mm-dd').slice(0, 10);
        }
        websocketService.sendRequestFor.residenceListSend();
      });
    });

    $scope.$on('set-settings', function (e, response) {
      if (response) {
        $translate(['profile.success', 'profile.success_message']).then(function (translation) {
          alertService.displayAlert(translation['profile.success'], translation['profile.success_message']);
        });
      } else {
        $translate('profile.error_message').then(function (translation) {
          alertService.displayError(translation['profile.error_message']);
        });
      }
      vm.disableUpdateButton = false;
    });

    $scope.$on('set-settings:error', function (e, message) {
      alertService.displayError(message);
      vm.disableUpdateButton = false;
    });

    $scope.$on('residence_list', function (e, response) {
      if (response) {
        var country = _.find(response, ['text', vm.profile.country]);
        if (country) {
          websocketService.sendRequestFor.statesListSend(country.value);
        }
      }
    });

    $scope.$on('states_list', function (e, response) {
      if (response) {
        $scope.$applyAsync(function () {
          vm.states = response;
          vm.disableUpdateButton = false;
        });
      }
    });

    $scope.$on('authorize', function (e, response) {
      init();
    });

    init();

    vm.submit = function () {
      vm.disableUpdateButton = true;
      updateProfile();
    };

    function getProfile() {
      websocketService.sendRequestFor.accountSetting();
    }

    function updateProfile() {
      var address = {
        address_line_1: vm.profile.address_line_1,
        address_line_2: vm.profile.address_line_2,
        address_city: vm.profile.address_city,
        address_state: vm.profile.address_state,
        address_postcode: vm.profile.address_postcode,
        phone: vm.profile.phone
      };

      websocketService.sendRequestFor.setAccountSettings(address);
    }

    function init() {
      getProfile();
      vm.isVirtualAccount = appStateService.virtuality;
    }
  }
})();
'use strict';

/**
 * @name profit-table controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.profit-table.controllers').controller('ProfitTableController', ProfitTable);

    ProfitTable.$inject = ['$scope', '$filter', '$timeout', '$state', '$templateCache', '$ionicScrollDelegate', 'config', 'tableStateService', 'websocketService', 'appStateService'];

    function ProfitTable($scope, $filter, $timeout, $state, $templateCache, $ionicScrollDelegate, config, tableStateService, websocketService, appStateService) {
        var vm = this;
        vm.data = {};
        vm.noTransaction = false;
        vm.noMore = false;
        vm.hasRefresh = false;
        vm.enteredNow = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        vm.goToTopButton = false;
        vm.backFromMainPages = false;
        vm.firstCompleted = false;
        vm.noMoreRequest = false;
        vm.jumpToDateInputShow = false;
        vm.hasError = false;
        vm.dateChanged = false;
        vm.appIdAllowed = config.app_id;

        $scope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
            vm.lastPage = from.name;
            vm.enteredNow = true;
            vm.thisPage = to.name;
            // check if state is changed from any state other than transactiondetail
            // we do not refresh the state if it comes back from transactiondetail
            if (vm.lastPage != 'transactiondetail' && vm.thisPage == 'profittable') {
                vm.resetParams();
                vm.firstCompleted = false;
                vm.backFromMainPages = true;
                vm.jumpToDateInputShow = false;
                vm.notAuthorizeYet();
            }
        });

        $scope.$on('authorize', function (e, response) {
            if (appStateService.profitTableRefresh) {
                vm.notAuthorizeYet();
            }
        });

        vm.notAuthorizeYet = function () {
            // check if app is authorized already or has to wait for it to be authorized
            if (appStateService.isLoggedin) {
                if (appStateService.profitTableRefresh || vm.backFromMainPages) {
                    $templateCache.remove();
                    vm.resetParams();
                    vm.jumpToDateInputShow = false;
                    vm.firstCompleted = false;
                    vm.noMoreRequest = false;
                    vm.filteredTransactions = [];
                    vm.noTransaction = false;
                    vm.hasError = false;
                    vm.backFromMainPages = false;
                    tableStateService.completedGroup = true;
                    appStateService.profitTableRefresh = false;
                    appStateService.isProfitTableSet = false;
                    vm.hasError = false;
                    vm.loadMore();
                }
            }
            // else{
            //    wait for authorize
            // }
        };

        vm.delayedLoad = function () {
            $timeout(vm.loadMore, 50);
        };

        vm.loadMore = function () {
            if (!tableStateService.completedGroup) {
                // here can load some amount of transactions already recieved
                vm.setBatch();
            } else if (tableStateService.completedGroup) {
                tableStateService.currentPage += 1;
                vm.pageState();
            }
        };

        vm.pageState = function () {
            if (!appStateService.isProfitTableSet) {
                appStateService.isProfitTableSet = true;
                tableStateService.dateType = 'allTime';
                vm.jumpToDateInputShow = false;
                vm.resetParams();
                vm.setParams();
                tableStateService.completedGroup = false;
                vm.goTop();
            } else if (appStateService.isProfitTableSet && vm.enteredNow && vm.lastPage == 'transactiondetail') {
                vm.enteredNow = false;
                vm.lastPage = '';
                vm.setParams();
            } else if (appStateService.isProfitTableSet && vm.dateChanged && tableStateService.completedGroup) {
                vm.transactions = [];
                vm.batchedTransaction = [];
                vm.filteredTransactions = [];
                vm.dateChanged = false;
                tableStateService.currentPage = 0;
                tableStateService.batchNum = 0;
                tableStateService.batchLimit = 0;
                tableStateService.completedGroup = false;
                vm.setParams();
                vm.goTop();
            } else if (appStateService.isProfitTableSet && !vm.dateChanged && tableStateService.completedGroup) {
                vm.transactions = [];
                tableStateService.completedGroup = false;
                vm.setParams();
            } else {
                if (!vm.dateChanged) {
                    vm.setParams();
                    $scope.$applyAsync(function () {
                        vm.noMore = false;
                    });
                }
            }
            vm.sendRequest();
        };

        vm.setParams = function () {
            vm.data.appID = tableStateService.appID;
            vm.data.dateType = tableStateService.dateType;
            vm.data.dateFrom = tableStateService.dateFrom;
            vm.data.dateTo = tableStateService.dateTo;
            vm.data.currentPage = tableStateService.currentPage;
            vm.itemsPerPage = 300;
            vm.limit = vm.itemsPerPage + 1;
        };
        vm.resetParams = function () {
            tableStateService.appID = 'allApps';
            tableStateService.dateFrom = '';
            tableStateService.dateTo = '';
            tableStateService.currentPage = 0;
            vm.transactions = [];
            vm.batchedTransaction = [];
            tableStateService.completedGroup = true;
            tableStateService.batchNum = 0;
            tableStateService.batchLimit = 0;
        };

        vm.sendRequest = function () {
            vm.params = {
                "description": 1,
                "limit": vm.limit,
                "offset": vm.itemsPerPage * vm.data.currentPage
            };
            if (vm.data.hasOwnProperty('dateFrom') && vm.data.dateFrom != "") {
                vm.params.date_from = vm.data.dateFrom;
            }
            if (vm.data.hasOwnProperty('dateTo') && vm.data.dateTo != "") {
                vm.params.date_to = vm.data.dateTo + 8.64e+4;
            }
            vm.params.req_id = vm.data.dateTo || Math.round(new Date().getTime() / 1000);
            vm.reqId = vm.params.req_id;
            websocketService.sendRequestFor.profitTable(vm.params);
        };

        $scope.$on('profit_table:update', function (e, _profitTable, _req_id) {
            vm.firstCompleted = true;
            vm.profitTable = _profitTable;
            vm.count = vm.profitTable.count;
            vm.hasError = false;
            if (vm.reqId == _req_id) {
                if (vm.count == 0) {
                    vm.noTransaction = true;
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                    vm.setBatch();
                } else if (vm.count > 0) {
                    if (vm.count < vm.limit) {
                        // has no more to load on next call
                        vm.noTransaction = false;
                        // $scope.$applyAsync(() => {
                        vm.noMoreRequest = true;
                        // });
                        vm.profitTable.transactions.forEach(function (el, i) {
                            vm.transactions.push(vm.profitTable.transactions[i]);
                        });
                        vm.setBatch();
                    } else if (vm.count == vm.limit) {
                        // has at least one transaction on next call to show to user
                        vm.noTransaction = false;
                        $scope.$applyAsync(function () {
                            vm.noMore = false;
                        });
                        vm.profitTable.transactions.forEach(function (el, i) {
                            if (i < vm.count - 1) {
                                vm.transactions.push(vm.profitTable.transactions[i]);
                            }
                        });
                        vm.setBatch();
                    }
                }
            }
        });

        $scope.$on('profit_table:error', function (e, message) {
            $scope.$applyAsync(function () {
                vm.hasError = true;
                vm.errorMessage = message;
            });
        });

        vm.setBatch = function () {
            tableStateService.batchLimit = Math.ceil(vm.transactions.length / tableStateService.batchSize);
            vm.sliced = [];
            vm.sliced = vm.transactions.slice(tableStateService.batchNum * tableStateService.batchSize, (tableStateService.batchNum + 1) * tableStateService.batchSize);
            vm.sliced.forEach(function (el, i) {
                vm.batchedTransaction.push(vm.sliced[i]);
            });
            tableStateService.batchNum = tableStateService.batchNum + 1;
            if (tableStateService.batchNum == tableStateService.batchLimit) {
                tableStateService.batchLimit = 0;
                tableStateService.batchNum = 0;
                tableStateService.completedGroup = true;
                if (vm.noMoreRequest) {
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                }
            }

            vm.setFiltered();
        };

        vm.setFiltered = function () {
            $scope.$applyAsync(function () {
                tableStateService.appID = vm.data.appID;
                vm.filteredTransactions = $filter('DataFilter')(vm.batchedTransaction, tableStateService.appID, vm.appIdAllowed);
                if (vm.filteredTransactions.length == 0) {
                    vm.noTransaction = true;
                } else {
                    vm.noTransaction = false;
                }
                $scope.$broadcast('scroll.infiniteScrollComplete');
            });
        };

        vm.dateFilter = function () {
            tableStateService.dateType = vm.data.dateType;
            vm.dateChanged = true;
            vm.noTransaction = false;
            if (tableStateService.dateType == 'allTime') {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = false;
                });
                tableStateService.completedGroup = true;
                vm.firstCompleted = false;
                vm.data.dateTo = '';
                tableStateService.dateFrom = '';
                tableStateService.dateTo = '';
                vm.loadMore();
            } else if (tableStateService.dateType == 'jumpToDate') {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = true;
                });
                tableStateService.completedGroup = true;
                vm.firstCompleted = false;
                vm.nowDateInputLimit = $filter('date')(new Date(), 'yyyy-MM-dd');
                document.getElementById('dateTo').setAttribute('max', vm.nowDateInputLimit);
                document.getElementById('dateTo').value = vm.nowDateInputLimit;
                vm.jumpToDateFilter();
            }
        };

        vm.jumpToDateFilter = function () {
            if (tableStateService.dateType == 'jumpToDate') {
                tableStateService.completedGroup = true;
                vm.dateChanged = true;
                vm.noTransaction = false;
                vm.firstCompleted = false;
                tableStateService.currentPage = 0;
                vm.data.dateTo = new Date(vm.data.end).getTime() / 1000 || "";
                tableStateService.dateTo = vm.data.dateTo;
                vm.loadMore();
            }
        };

        vm.goTop = function () {
            $ionicScrollDelegate.scrollTop(true);
        };

        vm.goToTopButtonCondition = function () {
            $scope.$applyAsync(function () {
                if ($ionicScrollDelegate.$getByHandle('handler').getScrollPosition().top >= 30) {
                    vm.goToTopButton = true;
                } else if ($ionicScrollDelegate.$getByHandle('handler').getScrollPosition().top < 30) {
                    vm.goToTopButton = false;
                }
            });
        };

        // details functions
        vm.sendContractDetailRequest = function (id) {
            vm.id = id;
            sessionStorage.setItem('id', vm.id);
            $state.go('transactiondetail');
        };
    }
})();
'use strict';

/**
 * @name profit-table directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.profit-table.directives').directive('bgProfitTable', ProfitTable);

    function ProfitTable() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/profit-table/profit-table.template.html',
            controller: 'ProfitTableController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name profit-table filter
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
	'use strict';

	angular.module('binary.pages.profit-table.filters').filter('DataFilter', DataFilter);

	DataFilter.$inject = ['$filter'];

	function DataFilter(transactions, appID, appIdAllowed) {
		function DataChange(transactions, appID, appIdAllowed) {
			var filtered = [],
			    appID = appID,
			    appIdAllowed = appIdAllowed,
			    transactions = transactions;
			for (var i in transactions) {
				var item = transactions[i];
				var itemId = item.app_id;
				if (appID == 'allApps' || appID == 'tickTradeApp' && itemId === appIdAllowed) {
					filtered.push(item);
				}
			};
			return filtered;
		}
		return DataChange;
	};
	return DataFilter;
})();
'use strict';

/**
 * @name self-exclusion module
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/12/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.self-exclusion.controllers').controller('SelfExclusionController', SelfExclusion);

  SelfExclusion.$inject = ['$scope', '$translate', 'alertService', 'websocketService'];

  function SelfExclusion($scope, $translate, alertService, websocketService) {

    var vm = this;
    vm.disableUpdateButton = true;
    vm.data = {};

    $scope.$on('get-self-exclusion', function (e, response) {
      $scope.$applyAsync(function () {
        vm.data = response;
        vm.limits = _.clone(response);
        vm.disableUpdateButton = false;
      });
    });

    $scope.$on('get-self-exclusion:error', function (e, error) {
      alertService.displayError(error);
      vm.disableUpdateButton = false;
    });

    $scope.$on('set-self-exclusion', function (e, response) {
      $translate(['self-exclusion.success', 'self-exclusion.save-prompt']).then(function (translation) {
        alertService.displayAlert(translation['self-exclusion.success'], translation['self-exclusion.save-prompt']);
      });
      vm.limits = _.clone(vm.data);
      vm.disableUpdateButton = false;
      if (vm.data.exclude_until || vm.data.timeout_until) {
        websocketService.logout();
      }
    });

    $scope.$on('set-self-exclusion:error', function (e, error) {
      alertService.displayError(error);
      vm.disableUpdateButton = false;
    });

    vm.submit = function () {
      vm.disableUpdateButton = true;
      setSelfExclusion();
    };

    init();

    function getSelfExclusion() {
      websocketService.sendRequestFor.getSelfExclusion();
    }

    function setSelfExclusion() {
      var data = _.clone(vm.data);

      if (data.timeout_until) {
        data.timeout_until = new Date(data.timeout_until).getTime() / 1000;
      }

      if (data.exclude_until) {
        data.exclude_until = data.exclude_until.toISOString().slice(0, 10);
      }

      websocketService.sendRequestFor.setSelfExclusion(data);
    }

    function init() {
      getSelfExclusion();
    }
  }
})();
'use strict';

/**
 * @name settings controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/11/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.settings.controllers').controller('SettingsController', Settings);

  Settings.$inject = ['appStateService'];

  function Settings(appStateService) {
    var vm = this;

    vm.settings = [
    /*{
      name: "settings.security-and-limits",
      submenus: [
        {
          name: "settings.self-exclusion",
          url: "self-exclusion",
          scope: "admin",
          forRealAccount: true
        }
      ]
    },*/
    {
      name: "profile.personal_details",
      url: "profile",
      scope: "read",
      forRealAccount: false
    }, {
      name: "settings.self-exclusion",
      url: "self-exclusion",
      scope: "admin",
      forRealAccount: true
    }, {
      name: "menu.language",
      url: "language",
      scope: "read",
      forRealAccount: false
    }];

    vm.checkScope = function (scope) {
      // since users aren't able to sign-in by token scopes don't have meaning any more
      return true;
    };

    vm.checkAccount = function (forRealAccount) {
      if (forRealAccount) {
        return !appStateService.virtuality;
      }
      return true;
    };
  }
})();
'use strict';

/**
 * @name Singin Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/10/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    Signin.$inject = ["$scope", "$state", "$ionicLoading", "accountService", "languageService", "websocketService", "alertService", "appStateService"];
    angular.module('binary.pages.signin.controllers').controller('SigninController', Signin);

    Signin.$inejct = ['$scope', '$state', '$ionicLoading', 'accountService', 'languageService', 'websocketService', 'alertService', 'appStateService'];

    function Signin($scope, $state, $ionicLoading, accountService, languageService, websocketService, alertService, appStateService) {
        var vm = this;
        vm.showTokenForm = false;
        vm.showSignin = false;
        vm.showSignup = false;
        vm.showvirtualws = false;
        vm.data = {};
        vm.tokenError = false;
        vm.passwordError = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        vm.disableNextbutton = false;

        /**
         * On load:
         * Open the websocket
         * If default account is set, send it for validation
         */
        var init = function init() {
            vm.language = languageService.read();
        };

        init();

        $scope.$on('authorize', function (e, response, message) {

            $ionicLoading.hide();

            if (response) {
                if (accountService.isUnique(response.loginid)) {
                    accountService.add(response);
                    accountService.setDefault(response.token);
                    appStateService.virtuality = response.is_virtual;
                }

                vm.token = '';

                $state.go('trade');
            } else {
                alertService.accountError.tokenNotAuthenticated(message);
            }
        });

        /**
         * SignIn button: event handler
         * @param  {String} _token 15char token
         */
        vm.signIn = function () {
            var _token = vm.token;

            // Validate the token
            if (_token && _token.length === 15) {

                $ionicLoading.show();

                websocketService.authenticate(_token);
            } else {
                alertService.accountError.tokenNotValid();
            }
        };

        vm.changeLanguage = function () {
            languageService.update(vm.language);
        };

        // sign up email verify
        vm.verifyUserMail = function () {
            vm.emailError = false;
            if (vm.data.mail) {
                var mail = vm.data.mail;
            } else {
                var mail = "";
            }
            websocketService.sendRequestFor.accountOpening(mail);
        };
        $scope.$on('verify_email', function (e, verify_email) {
            vm.userMail = verify_email;
            if (vm.userMail == 1) {
                $scope.$applyAsync(function () {
                    vm.emailError = false;
                });
                $scope.$applyAsync(function () {
                    vm.showvirtualws = true;
                    vm.showSignup = false;
                });
            }
        });
        $scope.$on('verify_email:error', function (e, details) {
            $scope.$applyAsync(function () {
                vm.emailError = true;
                vm.emailErrorMessage = details.verify_email;
            });
        });

        // virtual ws opening
        $scope.$watch('vm.showSignup', function () {
            if (vm.showSignup) {
                websocketService.sendRequestFor.residenceListSend();
            }
        });

        $scope.$on('residence_list', function (e, residence_list) {
            vm.data.residenceList = residence_list;
        });

        // Hide & show password function
        vm.data.inputType = 'password';
        vm.hideShowPassword = function () {
            if (vm.data.inputType == 'password') vm.data.inputType = 'text';else vm.data.inputType = 'password';
        };

        vm.createVirtualAccount = function () {
            vm.tokenError = false;
            vm.passwordError = false;
            var verificationCode = vm.data.verificationCode;
            var clientPassword = vm.data.clientPassword;
            var residence = vm.data.residence;
            websocketService.sendRequestFor.newAccountVirtual(verificationCode, clientPassword, residence);
        };
        $scope.$on('new_account_virtual', function (e, new_account_virtual) {
            if (!appStateService.isLoggedin) {
                var _token = new_account_virtual.oauth_token;
                websocketService.authenticate(_token);
                vm.showTokenForm = false;
                vm.showSignin = false;
                vm.showSignup = false;
                vm.showvirtualws = false;
            }
        });
        $scope.$on('new_account_virtual:error', function (e, error) {
            $scope.$applyAsync(function () {
                if (error) {
                    if (error.hasOwnProperty('details') && error.details.hasOwnProperty('verification_code')) {
                        vm.tokenError = true;
                        vm.tokenErrorMessage = error.details.verification_code || error.code;
                    }
                    if (error.hasOwnProperty('code') && error.code == "InvalidToken") {
                        vm.tokenError = true;
                        vm.tokenErrorMessage = error.message;
                    }
                    if (error.hasOwnProperty('details') && error.details.hasOwnProperty('client_password')) {
                        vm.passwordError = true;
                        vm.passwordErrorMessage = error.details.client_password || error.code;
                    }
                    if (error.hasOwnProperty('code') && error.code == "PasswordError") {
                        vm.passwordError = true;
                        vm.passwordErrorMessage = error.message;
                    }
                }
            });
        });

        // change different type of singing methods
        vm.changeSigninView = function (_isBack) {
            _isBack = _isBack || false;

            $scope.$applyAsync(function () {
                if (!vm.showSignin && !vm.showSignup && !vm.showvirtualws && vm.showTokenForm) {
                    vm.showTokenForm = false;
                    vm.showSignin = true;
                } else if (!vm.showSignin && vm.showSignup && !vm.showTokenForm && !vm.showvirtualws) {
                    vm.showSignup = false;
                    vm.showSignin = true;
                } else if (!vm.showSignin && !vm.showSignup && !vm.showTokenForm && vm.showvirtualws) {
                    vm.showvirtualws = false;
                    vm.showSignup = false;
                    vm.showSignin = true;
                } else if (!vm.showSignin && vm.showSignup && !vm.showTokenForm && !vm.showvirtualws) {
                    vm.showvirtualws = false;
                    vm.showSignup = false;
                    vm.showSignin = true;
                } else if (vm.showSignin && !vm.showSignup && !vm.showTokenForm && !vm.showvirtualws && _isBack) {
                    vm.showSignin = false;
                }
            });
        };

        vm.changeSigninViewtoToken = function () {
            if (vm.showSignin && !vm.showTokenForm) {
                vm.showTokenForm = true;
                vm.showSignin = false;
            }
        };

        vm.changeSigninViewtoSignup = function () {
            if (vm.showSignin && !vm.showSignup) {
                vm.showSignup = true;
                vm.showSignin = false;
            }
        };

        vm.showSigninView = function () {
            $scope.$applyAsync(function () {
                vm.showSignin = true;
            });
        };

        $scope.$watch(function () {
            return appStateService.isLanguageReady;
        }, function (newValue, oldValue) {
            vm.disableNextbutton = !newValue;
        });
    }
})();
'use strict';

/**
 * @name statement controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.statement.controllers').controller('StatementController', Statement);

    Statement.$inject = ['$scope', '$filter', '$timeout', '$state', '$templateCache', '$ionicScrollDelegate', 'config', 'tableStateService', 'websocketService', 'appStateService'];

    function Statement($scope, $filter, $timeout, $state, $templateCache, $ionicScrollDelegate, config, tableStateService, websocketService, appStateService) {
        var vm = this;
        vm.data = {};
        vm.noTransaction = false;
        vm.noMore = false;
        vm.hasRefresh = false;
        vm.enteredNow = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        vm.goToTopButton = false;
        vm.backFromMainPages = false;
        vm.firstCompleted = false;
        vm.noMoreRequest = false;
        vm.jumpToDateInputShow = false;
        vm.hasError = false;
        vm.dateChanged = false;
        vm.appIdAllowed = config.app_id;

        $scope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
            vm.lastPage = from.name;
            vm.enteredNow = true;
            vm.thisPage = to.name;
            // check if state is changed from any state other than transactiondetail
            // we do not refresh the state if it comes back from transactiondetail
            if (vm.lastPage != 'transactiondetail' && vm.thisPage == 'statement') {
                vm.resetParams();
                vm.firstCompleted = false;
                vm.backFromMainPages = true;
                vm.jumpToDateInputShow = false;
                vm.notAuthorizeYet();
            }
        });

        $scope.$on('authorize', function (e, response) {
            if (appStateService.statementRefresh) {
                vm.notAuthorizeYet();
            }
        });

        vm.notAuthorizeYet = function () {
            // check if app is authorized already or has to wait for it to be authorized
            if (appStateService.isLoggedin) {
                if (appStateService.statementRefresh || vm.backFromMainPages) {
                    $templateCache.remove();
                    vm.resetParams();
                    vm.jumpToDateInputShow = false;
                    vm.firstCompleted = false;
                    vm.noMoreRequest = false;
                    vm.hasError = false;
                    vm.filteredTransactions = [];
                    vm.noTransaction = false;
                    vm.backFromMainPages = false;
                    tableStateService.statementCompletedGroup = true;
                    appStateService.statementRefresh = false;
                    appStateService.isStatementSet = false;
                    vm.hasError = false;
                    vm.loadMore();
                }
            }
            // else{
            //    wait for authorize
            // }
        };

        vm.delayedLoad = function () {
            $timeout(vm.loadMore, 50);
        };

        vm.loadMore = function () {
            if (!tableStateService.statementCompletedGroup) {
                // here can load some amount of transactions already recieved
                vm.setBatch();
            } else if (tableStateService.statementCompletedGroup) {
                tableStateService.statementCurrentPage += 1;
                vm.pageState();
            }
        };

        vm.pageState = function () {
            if (!appStateService.isStatementSet) {
                appStateService.isStatementSet = true;
                tableStateService.statementDateType = 'allTime';
                vm.jumpToDateInputShow = false;
                vm.resetParams();
                vm.setParams();
                tableStateService.statementCompletedGroup = false;
                vm.goTop();
            } else if (!appStateService.isStatementSet && vm.enteredNow && vm.lastPage == 'transactiondetail') {
                vm.enteredNow = false;
                vm.lastPage = '';
                vm.setParams();
            } else if (appStateService.isStatementSet && vm.dateChanged && tableStateService.statementCompletedGroup) {
                vm.transactions = [];
                vm.batchedTransaction = [];
                vm.filteredTransactions = [];
                vm.dateChanged = false;
                tableStateService.statementCurrentPage = 0;
                tableStateService.statementBatchNum = 0;
                tableStateService.statementBatchLimit = 0;
                tableStateService.statementCompletedGroup = false;
                vm.setParams();
                vm.goTop();
            } else if (appStateService.isStatementSet && !vm.dateChanged && tableStateService.statementCompletedGroup) {
                vm.transactions = [];
                tableStateService.statementCompletedGroup = false;
                vm.setParams();
            } else {
                if (!vm.dateChanged) {
                    vm.setParams();
                    $scope.$applyAsync(function () {
                        vm.noMore = false;
                    });
                }
            }
            vm.sendRequest();
        };

        vm.setParams = function () {
            vm.data.appID = tableStateService.statementAppID;
            vm.data.dateType = tableStateService.statementDateType;
            vm.data.dateFrom = tableStateService.statementDateFrom;
            vm.data.dateTo = tableStateService.statementDateTo;
            vm.data.statementCurrentPage = tableStateService.statementCurrentPage;
            vm.itemsPerPage = 300;
            vm.limit = vm.itemsPerPage + 1;
        };
        vm.resetParams = function () {
            tableStateService.statementAppID = 'allApps';
            tableStateService.statementDateFrom = '';
            tableStateService.statementDateTo = '';
            tableStateService.statementCurrentPage = 0;
            vm.transactions = [];
            vm.batchedTransaction = [];
            tableStateService.statementCompletedGroup = true;
            tableStateService.statementBatchNum = 0;
            tableStateService.statementBatchLimit = 0;
        };

        vm.sendRequest = function () {
            vm.params = {
                "description": 1,
                "limit": vm.limit,
                "offset": vm.itemsPerPage * vm.data.statementCurrentPage
            };
            if (vm.data.hasOwnProperty('dateFrom') && vm.data.dateFrom != "") {
                vm.params.date_from = vm.data.dateFrom;
            }
            if (vm.data.hasOwnProperty('dateTo') && vm.data.dateTo != "") {
                vm.params.date_to = vm.data.dateTo + 8.64e+4;
            }
            vm.params.req_id = vm.data.dateTo || Math.round(new Date().getTime() / 1000);
            vm.reqId = vm.params.req_id;
            websocketService.sendRequestFor.statement(vm.params);
        };

        $scope.$on('statement:update', function (e, _statement, _req_id) {
            vm.firstCompleted = true;
            vm.statement = _statement;
            vm.count = vm.statement.count;
            vm.hasError = false;
            if (vm.reqId == _req_id) {
                if (vm.count == 0) {
                    vm.noTransaction = true;
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                    vm.setBatch();
                } else if (vm.count > 0) {
                    if (vm.count < vm.limit) {
                        // has no more to load on next call
                        vm.noTransaction = false;
                        // $scope.$applyAsync(() => {
                        vm.noMoreRequest = true;
                        // });
                        vm.statement.transactions.forEach(function (el, i) {
                            vm.transactions.push(vm.statement.transactions[i]);
                        });
                        vm.setBatch();
                    } else if (vm.count == vm.limit) {
                        // has at least one transaction on next call to show to user
                        vm.noTransaction = false;
                        $scope.$applyAsync(function () {
                            vm.noMore = false;
                        });
                        vm.statement.transactions.forEach(function (el, i) {
                            if (i < vm.count - 1) {
                                vm.transactions.push(vm.statement.transactions[i]);
                            }
                        });
                        vm.setBatch();
                    }
                }
            }
        });

        $scope.$on('statement:error', function (e, message) {
            $scope.$applyAsync(function () {
                vm.hasError = true;
                vm.errorMessage = message;
            });
        });

        vm.setBatch = function () {
            tableStateService.statementBatchLimit = Math.ceil(vm.transactions.length / tableStateService.statementBatchSize);
            vm.sliced = [];
            vm.sliced = vm.transactions.slice(tableStateService.statementBatchNum * tableStateService.statementBatchSize, (tableStateService.statementBatchNum + 1) * tableStateService.statementBatchSize);
            vm.sliced.forEach(function (el, i) {
                vm.batchedTransaction.push(vm.sliced[i]);
            });
            tableStateService.statementBatchNum = tableStateService.statementBatchNum + 1;
            if (tableStateService.statementBatchNum == tableStateService.statementBatchLimit) {
                tableStateService.statementBatchLimit = 0;
                tableStateService.statementBatchNum = 0;
                tableStateService.statementCompletedGroup = true;
                if (vm.noMoreRequest) {
                    $scope.$applyAsync(function () {
                        vm.noMore = true;
                    });
                }
            }

            vm.setFiltered();
        };

        vm.setFiltered = function () {
            $scope.$applyAsync(function () {
                tableStateService.statementAppID = vm.data.appID;
                vm.filteredTransactions = $filter('StatementDataFilter')(vm.batchedTransaction, tableStateService.statementAppID, vm.appIdAllowed);
                if (vm.filteredTransactions.length == 0) {
                    vm.noTransaction = true;
                } else {
                    vm.noTransaction = false;
                }
                $scope.$broadcast('scroll.infiniteScrollComplete');
            });
        };

        vm.dateFilter = function () {
            vm.noTransaction = false;
            vm.dateChanged = true;
            tableStateService.statementDateType = vm.data.dateType;
            if (vm.data.dateType == 'allTime') {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = false;
                });
                tableStateService.statementCompletedGroup = true;
                vm.firstCompleted = false;
                vm.data.dateTo = '';
                tableStateService.statementDateFrom = '';
                tableStateService.statementDateTo = '';
                vm.loadMore();
            }
            if (vm.data.dateType == 'jumpToDate') {
                $scope.$applyAsync(function () {
                    vm.jumpToDateInputShow = true;
                });
                tableStateService.statementCompletedGroup = true;
                vm.firstCompleted = false;
                vm.nowDateInputLimit = $filter('date')(new Date(), 'yyyy-MM-dd');
                document.getElementById('statement-dateTo').setAttribute('max', vm.nowDateInputLimit);
                document.getElementById('statement-dateTo').value = vm.nowDateInputLimit;
                vm.jumpToDateFilter();
            }
        };

        vm.jumpToDateFilter = function () {
            if (tableStateService.statementDateType == 'jumpToDate') {
                tableStateService.statementCompletedGroup = true;
                vm.dateChanged = true;
                vm.noTransaction = false;
                vm.firstCompleted = false;
                tableStateService.statementCurrentPage = 0;
                vm.data.dateTo = new Date(vm.data.end).getTime() / 1000 || "";
                tableStateService.statementDateTo = vm.data.dateTo;
                vm.loadMore();
            }
        };

        vm.goTop = function () {
            $ionicScrollDelegate.scrollTop(true);
        };

        vm.goToTopButtonCondition = function () {
            $scope.$applyAsync(function () {
                if ($ionicScrollDelegate.$getByHandle('handler').getScrollPosition().top >= 30) {
                    vm.goToTopButton = true;
                } else if ($ionicScrollDelegate.$getByHandle('handler').getScrollPosition().top < 30) {
                    vm.goToTopButton = false;
                }
            });
        };

        // details functions
        vm.sendContractDetailRequest = function (id) {
            if (id) {
                vm.id = id;
                sessionStorage.setItem('id', vm.id);
                $state.go('transactiondetail');
            }
        };
    }
})();
'use strict';

/**
 * @name statement directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.statement.directives').directive('bgStatement', Statement);

    function Statement() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/statement/statement.template.html',
            controller: 'StatementController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name profit-table filter
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
	'use strict';

	angular.module('binary.pages.statement.filters').filter('StatementDataFilter', StatementDataFilter);

	StatementDataFilter.$inject = ['$filter'];

	function StatementDataFilter(transactions, appID, appIdAllowed) {
		function DataChange(transactions, appID, appIdAllowed) {
			var filtered = [],
			    appID = appID,
			    appIdAllowed = appIdAllowed,
			    transactions = transactions;
			for (var i in transactions) {
				var item = transactions[i];
				var itemId = item.app_id;
				if (appID == 'allApps' || appID == 'tickTradeApp' && itemId === appIdAllowed) {
					filtered.push(item);
				}
			};
			return filtered;
		}
		return DataChange;
	};
	return StatementDataFilter;
})();
'use strict';

/**
 * @name terms and conditions controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.terms-and-conditions.controllers').controller('TermsAndConditionsController', TermsAndConditions);

    TermsAndConditions.$inject = ['$scope', '$state', 'websocketService', 'accountService', 'appStateService'];

    function TermsAndConditions($scope, $state, websocketService, accountService, appStateService) {
        var vm = this;
        $scope.$on('get_settings', function (e, get_settings) {
            vm.clientTncStatus = get_settings.client_tnc_status;
            vm.termsConditionsVersion = localStorage.getItem('termsConditionsVersion');
            if (!appStateService.virtuality && vm.clientTncStatus !== vm.termsConditionsVersion) {
                $state.go('acceptTermsAndConditions');
            }
        });
    }
})();
'use strict';

/**
 * @name terms and conditions directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.terms-and-conditions.directives').directive('bgTermsAndConditions', TermsAndConditions);

    function TermsAndConditions() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/terms-and-conditions/terms-and-conditions.template.html',
            controller: 'TermsAndConditionsController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name proposal service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.services').factory('proposalService', Proposal);

    Proposal.$inject = ['$rootScope', 'websocketService'];

    function Proposal($rootScope, websocketService) {
        var factory = {};

        factory.get = function () {
            if (_.isEmpty(localStorage.options)) {
                return create();
            }
            var options = JSON.parse(localStorage.options);
            var proposal = create();
            proposal.symbol = options.underlying.symbol;
            proposal.duration = options.tick;
            if (options.tradeType === 'Higher/Lower') {
                proposal.barrier = _.isEmpty(options.barrier) ? "" : options.barrier;
            } else {
                proposal.barrier = options.digit;
            }
            proposal.tradeType = options.tradeType;
            proposal.amount = options.amount || proposal.amount;
            proposal.basis = options.basis || proposal.basis;
            proposal.currency = sessionStorage.currency || 'USD';
            return proposal;
        };

        factory.save = function (options) {
            localStorage.options = JSON.stringify(options);
        };

        factory.setPropertyValue = function (propertyName, value) {
            var options = JSON.parse(localStorage.options);
            options[propertyName] = value;
            localStorage.options = JSON.stringify(options);
            $rootScope.$broadcast('options:updated', options);
        };

        factory.update = function (options) {
            var proposal = factory.get();

            proposal.symbol = options.underlying.symbol;
            proposal.duration = options.tick;
            if (options.tradeType === 'Higher/Lower') {
                proposal.barrier = _.isEmpty(options.barrier) ? "" : options.barrier;
            } else {
                proposal.barrier = options.digit;
            }
            proposal.tradeType = options.tradeType;
            proposal.amount = options.amount || proposal.amount;
            proposal.basis = options.basis || proposal.basis;

            factory.save(options);
            return proposal;
        };

        factory.send = function (proposal) {
            delete proposal.tradeType;
            if (validate(proposal)) {
                websocketService.sendRequestFor.proposal(proposal);
            }
        };

        factory.forget = function () {
            websocketService.sendRequestFor.forgetProposals();
        };

        factory.purchase = function (contract) {
            websocketService.sendRequestFor.purchase(contract.id, contract.ask_price);
            factory.forget();
        };

        function create() {
            var proposal = {
                subscribe: 1,
                proposal: 1,
                symbol: null,
                contract_type: null,
                duration: null,
                basis: 'payout',
                currency: sessionStorage.currency || 'USD',
                amount: 5,
                duration_unit: 't',
                passthrough: null
            };

            return proposal;
        }

        function validate(proposal) {
            _.forEach(proposal, function (value, key) {
                if (value == null) {
                    delete proposal[key];
                }
            });
            return true;

            var contraints = {
                amount: {
                    presence: true,
                    format: {
                        pattern: /^(\d+\.?\d{0,2}|\.\d{1,2})$/

                    }
                },
                basis: {
                    persence: true,
                    format: {
                        pattern: /^payout|stake$/
                    }
                },
                contract_type: {
                    persence: true,
                    format: {
                        pattern: /^\w{2,30}$/
                    }
                },
                currency: {
                    persence: true,
                    format: {
                        pattern: /^[A-Z]{3}$/
                    }
                },
                duration: {
                    persence: true,
                    format: {
                        pattern: /^\d+$/
                    }
                },
                duration_unit: {
                    persence: true,
                    format: {
                        pattern: /^d|m|s|h|t$/
                    }
                },
                symbol: {
                    persence: true,
                    format: {
                        pattern: /^\w{2,30}$/
                    }
                },
                barrier: {
                    persence: false,
                    format: {
                        pattern: /^[+-]?\d+\.?\d*$/
                    }
                }

            };

            if (_.isEmpty(validate(proposal, contraints))) {
                return true;
            }

            return false;
        }

        return factory;
    }
})();
'use strict';

/**
 * @name trade controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.controllers').controller('TradeController', Trade);

    Trade.$inject = ['$scope', 'proposalService', 'tradeService', 'websocketService', 'alertService'];

    function Trade($scope, proposalService, tradeService, websocketService, alertService) {
        var vm = this;

        vm.proposal = {};
        vm.purchasedContract = {};

        function init() {
            vm.proposal = proposalService.get();
        }

        init();

        angular.element(document).ready(function () {
            if (ionic.Platform.isIOS()) {
                document.getElementById('trade-container').style.paddingBottom = '20px';
            }
            window.addEventListener('native.keyboardshow', keyboardShowHandler);
            window.addEventListener('native.keyboardhide', keyboardHideHandler);

            function keyboardShowHandler(e) {
                document.getElementById('trade-container').className = "";
            }

            function keyboardHideHandler(e) {
                document.getElementById('trade-container').className = "flexed";
            }
        });
    }
})();
'use strict';

/**
 * @name trade save
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.services').factory('tradeService', Trade);

    function Trade() {
        var factory = {};

        factory.proposalIsReady = false;

        return factory;
    }
})();
'use strict';

/**
 * @name transaction-detail controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.transaction-detail.controllers').controller('TransactionDetailController', TransactionDetail);

    TransactionDetail.$inject = ['$scope', '$timeout', '$interval', '$state', 'appStateService', 'websocketService'];

    function TransactionDetail($scope, $timeout, $interval, $state, appStateService, websocketService) {
        var vm = this;

        vm.currency = sessionStorage.getItem('currency');

        vm.data = {};
        vm.data.id = sessionStorage.getItem('id');
        vm.data.extraParams = {
            'req_id': vm.data.id
        };
        vm.sendDetailsRequest = function () {
            if (appStateService.isLoggedin) {
                websocketService.sendRequestFor.openContract(vm.data.id, vm.data.extraParams);
            } else {
                $timeout(vm.sendDetailsRequest, 500);
            }
        };

        $scope.$on('proposal:open-contract', function (e, proposal_open_contract, req_id) {
            vm.proposalOpenContract = proposal_open_contract;
            vm.data.reqId = req_id;
            if (vm.data.reqId == vm.data.id) {
                $scope.$applyAsync(function () {
                    vm.contract = vm.proposalOpenContract;
                });
            }
        });

        vm.sendDetailsRequest();
    }
})();
'use strict';

/**
 * @name transaction-detail directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.transaction-detail.directives').directive('bgTransactionDetail', TransactionDetail);

    function TransactionDetail() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/transaction-detail/transaction-detail.template.html',
            controller: 'TransactionDetailController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name update controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/26/2015
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.update.controllers').controller('UpdateController', Update);

  Update.$inject = ['$http', '$scope', 'languageService'];

  function Update($http, $scope, languageService) {
    var vm = this;
    vm.storeLogo = null;
    vm.lastVersion = null;
    vm.showSpinner = true;
    vm.platform = null;

    vm.openExternal = function ($event) {
      window.open($event.currentTarget.href, "_system");
      return false;
    };

    init();

    function init() {
      getVersions();
    }

    function getVersions() {
      $http({
        method: 'GET',
        url: 'versions.json'
      }).then(function (response) {
        if (response.data) {
          $scope.$applyAsync(function () {
            vm.showSpinner = false;
            var versions = response.data;
            vm.lastVersion = versions.pop();
            generateStoreLogo();
          });
        }
      }, function (error) {
        vm.versions = null;
        console.log(error);
      });
    }

    function generateStoreLogo() {
      var language = languageService.read();
      vm.platform = 'appstore';
      if (ionic.Platform.isAndroid()) {
        vm.platform = 'googleplay';
      }
      vm.storeLogo = 'img/' + vm.platform + '/' + language + '.svg';
    }
  }
})();
'use strict';

/**
 * @name accountService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/26/2015
 * @copyright Binary Ltd
 */

angular.module('binary').service('accountService', ["websocketService", "appStateService", "delayService", function (websocketService, appStateService, delayService) {
	/**
  * find a {key,value} in an array of objects and return its index
  * returns -1 if not found
  * @param  {Array of Objects} _accounts
  * @param  {String} _key
  * @param  {String, Number, Boolean} _value
  * @return {Number} Index of the found array element
  */

	this.addedAccount = '';
	var findIndex = function findIndex(_accounts, _key, _value) {
		var index = -1;
		_accounts.forEach(function (el, i) {
			if (_accounts[i][_key] === _value) {
				index = i;
			}
		});
		return index;
	};

	/**
  * Check if the 'accounts' localStorage exist
  * @return {Boolean}
  */
	var storageExist = function storageExist() {
		return localStorage.accounts && JSON.parse(localStorage.accounts) instanceof Array;
	};

	/**
  * Returns the list of all accounts
  * @return {Array}
  */
	this.getAll = function () {
		return storageExist() ? JSON.parse(localStorage.accounts) : [];
	};

	/**
  * Removes the 'accounts' localStorage
  */
	this.removeAll = function () {
		localStorage.removeItem('accounts');
	};

	/**
  * Send a token for validation
  * if '_token' param is not passed, validates the default token
  * @param  {String} _token
  */
	var validate = function validate(_token, extraParams) {
		//Remove the last delay queue of 'symbolsAndAssetIndexUpdate'
		delayService.remove('symbolsAndAssetIndexUpdate');

		if (_token) {
			websocketService.authenticate(_token, extraParams);
		} else {
			var accountList = this.getAll();
			var defaultAccountIndex = findIndex(accountList, 'is_default', true);
			// If default account exist
			if (defaultAccountIndex > -1) {
				var token = accountList[defaultAccountIndex].token;
				websocketService.authenticate(token, extraParams);
			}
		}
	};

	this.validate = function (_token, extraParams) {
		if (!_token) {
			var accountList = this.getAll();
			var defaultAccountIndex = findIndex(accountList, 'is_default', true);
			// If default account exist
			if (defaultAccountIndex > -1) {
				_token = accountList[defaultAccountIndex].token;
			}
		}

		validate(_token, extraParams);
	};

	/**
  * Add an account to the 'accounts' localStorage
  * @param {Object} _account
  */
	this.add = function (_account) {
		var account = {
			id: _account.loginid,
			token: _account.token,
			currency: _account.currency || 'USD',
			email: _account.email,
			is_default: false
		};

		var accountList = this.getAll();

		if (_.find(accountList, ['id', account.id])) {
			return;
		}

		accountList.push(account);
		localStorage.accounts = JSON.stringify(accountList);
	};

	/**
  * Removes an account from 'accounts' localStorage
  * Doesn't remove the default account
  * @param  {String} _token
  */
	this.remove = function (_token) {
		var accountList = this.getAll();
		var index = findIndex(accountList, 'token', _token);
		// If the token exist and is not the default token
		if (index > -1 && accountList[index].is_default !== true) {
			accountList.splice(index, 1);
			localStorage.accounts = JSON.stringify(accountList);
		}
	};

	/**
  * Set the passed token as the default account
  * @param {String} _token
  */
	this.setDefault = function (_token) {
		var accountList = this.getAll();
		var index = findIndex(accountList, 'token', _token);
		// Make sure the token exist
		if (index > -1) {
			accountList.forEach(function (el, i) {
				accountList[i].is_default = accountList[i].token === _token ? true : false;
			});
			localStorage.accounts = JSON.stringify(accountList);
		}
	};

	/**
  * Check if the default account exist
  * @return {Boolean}
  */
	this.hasDefault = function () {
		var accountList = this.getAll();
		var index = findIndex(accountList, 'is_default', true);
		return index > -1 ? true : false;
	};

	/**
  * Returns the default account
  * @return {Object}
  */
	this.getDefault = function () {
		var accountList = this.getAll();
		var index = findIndex(accountList, 'is_default', true);
		return accountList[index];
	};

	/**
  * Check if the token/account is unique
  * Only one token for each account is allowed
  * @param  {String}  _id : loginid
  * @return {Boolean}
  */
	this.isUnique = function (_id) {
		var accountList = this.getAll();
		var index = findIndex(accountList, 'id', _id);
		return index > -1 ? false : true;
	};

	this.checkScope = function (_scope) {
		var scopes = _.concat([], _scope);
		var result = false;

		if (appStateService.isLoggedin && !_.isEmpty(appStateService.scopes)) {
			result = true;
			for (var s in scopes) {
				if (appStateService.scopes.indexOf(scopes[s].toLowerCase()) < 0) {
					result = false;
					break;
				}
			}
		}
		return result;
	};
}]);
'use strict';

/**
 * @name alertService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/26/2015
 * @copyright Binary Ltd
 */

angular.module('binary').service('alertService', ["$translate", "$ionicPopup", "$rootScope", function ($translate, $ionicPopup, $rootScope) {
	var displayAlert = function displayAlert(_title, _message) {
		if (navigator.notification === undefined) {
			var alertPopup = $ionicPopup.alert({
				title: _title,
				template: _message
			});
		} else {
			navigator.notification.alert(_message, null, _title, 'OK');
		}
	};

	var displayConfirmation = function displayConfirmation(_title, _message, _buttons, _callback) {
		if (navigator.notification === undefined) {
			var confirmPopup = $ionicPopup.confirm({
				title: _title,
				template: _message
			});
			confirmPopup.then(_callback);
		} else {
			navigator.notification.confirm(_message, _callback, _title, _buttons);
		}
	};

	this.displayRealitCheckInterval = function (_title, _class, scope, _template, _buttons, _callback) {
		var showPopup = $ionicPopup.show({
			title: _title,
			cssClass: _class,
			scope: scope,
			templateUrl: _template,
			buttons: _buttons
		});
		showPopup.then(_callback);
	};

	this.displayRealityCheckResult = function (_title, _class, scope, _template, _buttons, _callback) {
		var showPopup = $ionicPopup.show({
			title: _title,
			cssClass: _class,
			scope: scope,
			templateUrl: _template,
			buttons: _buttons
		});
		showPopup.then(_callback);
	};

	this.displayError = function (_message) {
		$translate(['alert.error']).then(function (translation) {
			displayAlert(translation['alert.error'], _message);
		});
	};

	this.displaySymbolWarning = function (_message, _callback) {
		$translate(['alert.warning', _message]).then(function (translation) {
			displayAlert(translation['alert.warning'], translation[_message]);
		});
	};

	this.accountError = {
		tokenNotValid: function tokenNotValid() {
			$translate(['alert.error', 'alert.not_valid']).then(function (translation) {
				displayAlert(translation['alert.error'], translation['alert.not_valid']);
				//navigator.notification.alert(translation['alert.not_valid'], null, translation['alert.error'], 'OK');
			});
		},
		tokenNotAuthenticated: function tokenNotAuthenticated(message) {
			$translate(['alert.error', 'alert.not_auth']).then(function (translation) {
				displayAlert(translation['alert.error'], message ? message : translation['alert.not_auth']);
			});
		},
		tokenNotUnique: function tokenNotUnique() {
			$translate(['alert.error', 'alert.not_unique']).then(function (translation) {
				displayAlert(translation['alert.error'], translation['alert.not_unique']);
			});
		}
	};

	this.contractError = {
		notAvailable: function notAvailable() {
			$translate(['alert.error', 'alert.contract_error']).then(function (translation) {
				displayAlert(translation['alert.error'], translation['alert.contract_error']);
			});
		}
	};

	this.optionsError = {
		noTick: function noTick() {
			$translate(['alert.error', 'alert.no_tick']).then(function (translation) {
				displayAlert(translation['alert.error'], translation['alert.no_tick']);
			});
		}
	};

	this.displayAlert = function (_title, _message) {
		displayAlert(_title, _message);
	};

	this.confirmAccountRemoval = function (_token) {
		$translate(['alert.remove_token_title', 'alert.remove_token_content']).then(function (translation) {
			displayConfirmation(translation['alert.remove_token_title'], translation['alert.remove_token_content'], ['Yes', 'No'], function (res) {
				if (!(typeof res === "boolean")) {
					if (res == 1) res == true;else res = false;
				}

				if (res) {
					$rootScope.$broadcast('token:remove', _token);
				}
			});
		});
	};

	this.confirmRemoveAllAccount = function (_callback) {
		$translate(['alert.remove_all_tokens_title', 'alert.remove_all_tokens_content']).then(function (translation) {
			displayConfirmation(translation['alert.remove_all_tokens_title'], translation['alert.remove_all_tokens_content'], ['Yes', 'No'], _callback);
		});
	};

	this.confirmExit = function (_callback) {
		$translate(['app.exit_title', 'app.exit_confirmation']).then(function (translation) {
			displayConfirmation(translation['app.exit_title'], translation['app.exit_confirmation'], ['Yes', 'No'], _callback);
		});
	};
}]);
'use strict';

/**
 * @name analyticsService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 07/17/2016
 * @copyright Binary Ltd
 * Send information to all analytics services
 */

angular.module('binary').factory('analyticsService', ["accountService", function (accountService) {
    var factory = {};
    factory.google = {
        addUser: function addUser() {
            var user = accountService.getDefault();
            var userId = user && user.id ? user.id : null;
            window.ga.setUserId(userId);
        },
        trackView: function trackView(_view) {
            if (typeof ga !== "undefined") {
                this.addUser();
                ga.trackView(_view);
            }
        },
        trackEvent: function trackEvent(market, contractType, symbole, payout) {
            if (typeof ga !== "undefined") {
                this.addUser();
                ga.trackEvent(market, contractType, symbole, payout);
            }
        }
    };

    factory.amplitude = {
        logEvent: function logEvent(title, data) {
            if (amplitude !== "undefined") {
                amplitude.logEvent(title, data);
            }
        }
    };

    return factory;
}]);
'use strict';

/**
 * @name appStateService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 05/02/2016
 * @copyright Binary Ltd
 * Keeping state of the app in this factory
 */

angular.module('binary').factory('appStateService', function () {
    var factory = {};
    factory.tradeMode = true;
    factory.purchaseMode = false;
    factory.isLoggedin = false;
    factory.waitForProposal = false;
    factory.scopes = [];
    factory.invalidTokenRemoved = false;
    factory.isChangedAccount = false;
    factory.isRealityChecked = false;
    factory.isPopupOpen = false;
    factory.hasGetResidence = false;
    factory.showForm = false;
    factory.isCheckedAccountType = false;
    factory.isNewAccountReal = false;
    factory.isNewAccountMaltainvest = false;
    factory.hasMLT = false;
    factory.isProfitTableSet = false;
    factory.profitTableRefresh = false;
    factory.isStatementSet = false;
    factory.statementRefresh = false;
    factory.virtuality = 0;
    factory.newAccountAdded = false;
    factory.isLanguageReady = false;

    return factory;
});
'use strict';

/**
 * @name appVersionService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 01/20/2016
 * @copyright Binary Ltd
 */

angular.module('binary').factory('appVersionService', ["$http", function ($http) {
                var appVersion = {};

                function getAppVersion() {
                                return $http.get('js/config.json');
                }

                appVersion.getAppVersion = getAppVersion;

                return appVersion;
}]);
'use strict';

/**
 * @name chartService
 * @author Amin Marashi
 * @contributors []
 * @since 11/25/2015
 * @copyright Binary Ltd
 */

angular.module('binary').factory('chartService', ["$rootScope", function ($rootScope) {

	var localHistory,
	    chartDrawer,
	    contractCtrls = [];

	/* Define ChartJS Options */
	var reversedIndex = function reversedIndex(i) {
		return chartGlobals.tickCount - 1 - i;
	};

	var distribute = function distribute(i) {
		var distance = Math.ceil(chartGlobals.tickCount / chartGlobals.minTickCount);
		if (reversedIndex(i) % distance === 0) {
			return true;
		} else {
			return false;
		}
	};

	var chartGlobals;
	var setChartGlobals = function setChartGlobals() {
		chartGlobals = {
			chartJS: null,
			capacity: 600,
			maxTickCount: 50,
			hideLabelsThreshold: 15,
			tickCount: 15,
			minTickCount: 5,
			chartData: {
				labels: [],
				labelsFilter: function labelsFilter(index) {
					return !distribute(index);
				},
				datasets: [{
					strokeColor: "#7cb5ec",
					pointColor: "#7cb5ec",
					pointStrokeColor: "#7cb5ec",
					data: []
				}]
			},
			chartOptions: {
				animation: false,
				bezierCurve: false,
				datasetFill: false,
				showTooltips: false,
				keepAspectRatio: false,
				scaleShowLabels: false,
				pointDotRadius: 3, //original 4
				datasetStrokeWidth: 2 }
		};
	};
	setChartGlobals();
	/* End of Define ChartJS Options */

	var utils = {
		zeroPad: function zeroPad(num) {
			if (num < 10) {
				return '0' + num;
			} else {
				return num.toString();
			}
		},
		getTickTime: function getTickTime(tick) {
			var date = new Date(tick * 1000);
			return date.getUTCHours() + ':' + utils.zeroPad(date.getUTCMinutes()) + ':' + utils.zeroPad(date.getUTCSeconds());
		},
		isDefined: function isDefined(obj) {
			if (typeof obj === 'undefined' || obj === null) {
				return false;
			} else {
				return true;
			}
		},
		setObjValue: function setObjValue(obj, attr, value, condition) {
			if (utils.isDefined(obj)) {
				if (utils.isDefined(condition)) {
					if (condition) {
						obj[attr] = value;
					}
				} else if (typeof obj[attr] === 'undefined') {
					obj[attr] = value;
				}
			}
		},
		fractionalLength: function fractionalLength(floatNumber) {
			var stringNumber = floatNumber.toString(),
			    decimalLength = stringNumber.indexOf('.');
			return stringNumber.length - decimalLength - 1;
		},
		maxFractionalLength: function maxFractionalLength(floatNumbers) {
			var max = 0;
			floatNumbers.forEach(function (number) {
				max = max < utils.fractionalLength(number) ? utils.fractionalLength(number) : max;
			});
			return max;
		},
		lastDigit: function lastDigit(num) {
			return parseInt(num.toString().slice(-1)[0]);
		},
		average: function average(list) {
			var decimalPointLength = utils.fractionalLength(list[0]) + 1;
			return parseFloat(list.reduce(function (a, b) {
				return a + b;
			}, 0) / list.length).toFixed(decimalPointLength);
		},
		conditions: {
			CALL: function condition(barrier, price) {
				return parseFloat(price) > parseFloat(barrier);
			},
			PUT: function condition(barrier, price) {
				return parseFloat(price) < parseFloat(barrier);
			},
			CALLHL: function condition(barrier, price) {
				// Higher/Lower CALL
				return parseFloat(price) > parseFloat(barrier);
			},
			PUTHL: function condition(barrier, price) {
				// Higher/Lower PUT
				return parseFloat(price) < parseFloat(barrier);
			},
			DIGITMATCH: function condition(barrier, price) {
				return utils.lastDigit(barrier) === utils.lastDigit(price);
			},
			DIGITDIFF: function condition(barrier, price) {
				return utils.lastDigit(barrier) !== utils.lastDigit(price);
			},
			DIGITEVEN: function condition(barrier, price) {
				return utils.lastDigit(price) % 2 === 0;
			},
			DIGITODD: function condition(barrier, price) {
				return utils.lastDigit(price) % 2 !== 0;
			},
			DIGITUNDER: function condition(barrier, price) {
				return utils.lastDigit(price) < parseInt(barrier);
			},
			DIGITOVER: function condition(barrier, price) {
				return utils.lastDigit(price) > parseInt(barrier);
			},
			ASIANU: function condition(barrier, price, priceList) {
				var avg = utils.average(priceList);

				return parseFloat(price) > avg;
			},
			ASIAND: function condition(barrier, price, priceList) {
				var avg = utils.average(priceList);

				return parseFloat(price) < avg;
			}
		},
		digitTrade: function digitTrade(contract) {
			if (contract.type.indexOf('DIGIT') === 0) {
				return true;
			}
			return false;
		},
		asianGame: function asianGame(contract) {
			if (contract.type.indexOf('ASIAN') === 0) {
				return true;
			}
			return false;
		},
		higherLowerTrade: function higherLowerTrade(contract) {
			if (['PUTHL', 'CALLHL'].indexOf(contract.type) > -1 && !_.isEmpty(contract.barrier)) {
				return true;
			}
			return false;
		},
		getRelativeIndex: function getRelativeIndex(absoluteIndex, dataIndex) {
			return absoluteIndex - (chartDrawer.getCapacity() - (chartDrawer.getTickCount() + chartDrawer.getDataIndex()));
		},
		getAbsoluteIndex: function getAbsoluteIndex(relativeIndex, dataIndex) {
			return relativeIndex + (chartDrawer.getCapacity() - (chartDrawer.getTickCount() + chartDrawer.getDataIndex()));
		}
	};

	var Stepper = function Stepper() {

		var tickDistance = 0,
		    startingPosition = 0,
		    startingDataIndex = 0,
		    started = false,
		    previousTime = 0;

		var setStartPosition = function setStartPosition(dataIndex, position) {
			startingPosition = position;
			startingDataIndex = dataIndex;
			started = true;
		};

		var stepCount = function stepCount(dataIndex, position) {
			if (!started) {
				return 0;
			}
			return startingDataIndex + Math.floor((position - startingPosition) / tickDistance) - dataIndex;
		};

		var setDistance = function setDistance(canvas, tickCount) {
			if (canvas !== null) {
				tickDistance = Math.ceil(canvas.offsetWidth / tickCount);
			}
		};

		var getDistance = function getDistance() {
			return tickDistance;
		};

		var isStep = function isStep(e, tickCount) {
			if (e.timeStamp - previousTime > 100) {
				previousTime = e.timeStamp;
				return true;
			}
			return false;
		};

		var stop = function stop() {
			started = false;
		};

		return {
			isStep: isStep,
			stop: stop,
			setDistance: setDistance,
			getDistance: getDistance,
			setStartPosition: setStartPosition,
			stepCount: stepCount
		};
	};

	var LocalHistory = function LocalHistory(capacity) {

		var historyData = [];

		var addTick = function addTick(tick) {
			if (parseInt(tick.epoch) > parseInt(historyData.slice(-1)[0].time)) {
				historyData.push({
					time: tick.epoch,
					price: tick.quote
				});
				historyData.shift();
			}
		};

		var updateHistoryArray = function updateHistoryArray(historyArray, history) {
			var times = history.times,
			    prices = history.prices;
			var compare = function compare(a, b) {
				var timea = parseInt(a.time),
				    timeb = parseInt(b.time);
				if (timea < timeb) {
					return -1;
				} else if (timea > timeb) {
					return 1;
				} else {
					return 0;
				}
			};
			var seenTimes = [];
			times.forEach(function (time, index) {
				if (seenTimes.indexOf(time) < 0) {
					seenTimes.push(time);
					historyArray.push({
						time: time,
						price: prices[index]
					});
				}
			});
			times.sort(compare);
		};

		var addHistory = function addHistory(history) {
			historyData = [];
			updateHistoryArray(historyData, history);
		};

		var getHistory = function getHistory(dataIndex, count, callback) {
			var end = capacity - dataIndex,
			    start = end - count;
			if (start >= 0) {
				callback(historyData.slice(start, end));
			} else {
				callback([]);
			}
		};

		return {
			getHistory: getHistory,
			addTick: addTick,
			addHistory: addHistory
		};
	};

	var ContractCtrl = function ContractCtrl(contract) {

		var broadcastable = true;
		var tickPriceList = [];

		var setNotBroadcastable = function setNotBroadcastable() {
			return broadcastable = false;
		};

		var getBroadcastable = function getBroadcastable() {
			return broadcastable;
		};

		var isFinished = function isFinished() {
			return utils.isDefined(contract.exitSpot);
		};

		var getContract = function getContract() {
			return contract;
		};

		var resetSpotShowing = function resetSpotShowing() {
			contract.showingEntrySpot = false;
			contract.showingExitSpot = false;
		};

		var hasEntrySpot = function hasEntrySpot() {
			if (utils.isDefined(contract.entrySpotIndex)) {
				return true;
			} else {
				return false;
			}
		};

		var hasExitSpot = function hasExitSpot() {
			if (utils.isDefined(contract.exitSpotIndex)) {
				return true;
			} else {
				return false;
			}
		};

		var betweenExistingSpots = function betweenExistingSpots(time) {
			if (hasEntrySpot() && time >= contract.entrySpotTime && (!hasExitSpot() || time <= contract.exitSpot)) {
				return true;
			} else {
				return false;
			}
		};

		var isSpot = function isSpot(i) {
			if (contract.showingEntrySpot && contract.entrySpotIndex === utils.getAbsoluteIndex(i)) {
				return true;
			}
			if (contract.showingExitSpot && contract.exitSpotIndex === utils.getAbsoluteIndex(i)) {
				return true;
			}
			return false;
		};

		var getEntrySpotPoint = function getEntrySpotPoint(points) {
			var result;
			if (contract.showingEntrySpot) {
				result = points[utils.getRelativeIndex(contract.entrySpotIndex)];
			}
			return result;
		};

		var getExitSpotPoint = function getExitSpotPoint(points) {
			var result;
			if (contract.showingExitSpot) {
				result = points[utils.getRelativeIndex(contract.exitSpotIndex)];
			}
			return result;
		};

		var isEntrySpot = function isEntrySpot(time) {
			if (hasEntrySpot()) {
				if (time === contract.entrySpotTime) {
					return true;
				} else {
					return false;
				}
			} else {
				if (time >= contract.startTime) {
					return true;
				} else {
					return false;
				}
			}
		};

		var isExitSpot = function isExitSpot(time, index) {
			if (hasExitSpot()) {
				if (time === contract.exitSpot) {
					return true;
				} else {
					return false;
				}
			} else {
				if (hasEntrySpot() && index === contract.entrySpotIndex + contract.duration) {
					return true;
				} else {
					return false;
				}
			}
		};

		var viewSpots = function viewSpots(index, tickTime) {
			if (isEntrySpot(tickTime)) {
				contract.showingEntrySpot = true;
				if (!utils.digitTrade(contract) && !utils.asianGame(contract) && !hasExitSpot()) {
					chartDrawer.addGridLine({
						color: '#2E8836',
						label: 'barrier: ' + contract.barrier,
						orientation: 'horizontal',
						type: 'barrier',
						index: index
					});
				} else if (utils.asianGame(contract) && tickPriceList.length > 0 && !hasExitSpot()) {
					chartDrawer.addGridLine({
						color: '#2E8836',
						label: 'Average: ' + utils.average(tickPriceList),
						orientation: 'horizontal',
						type: 'average',
						firstIndex: index,
						index: index + (tickPriceList.length - 1)
					});
				}
			} else if (isExitSpot(tickTime, utils.getAbsoluteIndex(index))) {
				contract.showingExitSpot = true;
			}
		};

		var addSpots = function addSpots(index, tickTime, tickPrice) {
			if (isEntrySpot(tickTime) || betweenExistingSpots(tickTime)) {
				if (isEntrySpot(tickTime)) {
					var barrier = tickPrice;
					if (utils.higherLowerTrade(contract)) {
						contract.offset = contract.offset || contract.barrier;
						barrier = Number(tickPrice) + Number(contract.offset);
						barrier = barrier.toFixed(utils.fractionalLength(tickPrice));
					}
					utils.setObjValue(contract, 'barrier', barrier, !utils.digitTrade(contract));
					utils.setObjValue(contract, 'entrySpotPrice', tickPrice, true);
					utils.setObjValue(contract, 'entrySpotTime', tickTime, !hasEntrySpot());
				} else if (isExitSpot(tickTime, index)) {
					utils.setObjValue(contract, 'exitSpot', tickTime, !hasExitSpot());
				}
				utils.setObjValue(contract, 'entrySpotIndex', index, isEntrySpot(tickTime));
				utils.setObjValue(contract, 'exitSpotIndex', index, isExitSpot(tickTime, index));

				//tickPriceList.push(tickPrice);
			}
		};

		var viewRegions = function viewRegions() {
			if (hasEntrySpot()) {
				var color = contract.result === 'win' ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)';
				if (contract.showingExitSpot) {
					var start = utils.getRelativeIndex(contract.entrySpotIndex);
					start = start < 0 ? 0 : start;
					if (!utils.isDefined(contract.region)) {
						contract.region = {
							color: color,
							start: start
						};
					} else {
						contract.region.color = color;
						contract.region.start = start;
					}
					contract.region.end = utils.getRelativeIndex(contract.exitSpotIndex);
					chartDrawer.addRegion(contract.region);
				} else if (contract.showingEntrySpot) {
					if (!utils.isDefined(contract.region)) {
						contract.region = {
							color: color,
							start: utils.getRelativeIndex(contract.entrySpotIndex)
						};
					} else {
						contract.region.color = color;
						contract.region.start = utils.getRelativeIndex(contract.entrySpotIndex);
					}
					chartDrawer.addRegion(contract.region);
				} else {
					chartDrawer.removeRegion(contract.region);
				}
			}
		};

		var addRegions = function addRegions(lastTime, lastPrice) {
			if (hasEntrySpot() && broadcastable) {

				if (tickPriceList.length === 0) {
					if (contract.entrySpotTime != lastTime && betweenExistingSpots(lastTime)) {
						tickPriceList.push(parseFloat(contract.entrySpotPrice));
						if (utils.conditions[contract.type](contract.barrier, contract.entrySpotPrice, tickPriceList)) {
							contract.result = 'win';
						} else {
							contract.result = 'lose';
						}
						$rootScope.$broadcast('contract:spot', contract, contract.entrySpotPrice);
					} else {
						tickPriceList.push(parseFloat(lastPrice));
					}
				} else {
					tickPriceList.push(parseFloat(lastPrice));
				}

				if (betweenExistingSpots(lastTime)) {
					if (utils.conditions[contract.type](contract.barrier, lastPrice, tickPriceList)) {
						contract.result = 'win';
					} else {
						contract.result = 'lose';
					}

					$rootScope.$broadcast('contract:spot', contract, lastPrice);

					if (isFinished() && broadcastable) {
						tickPriceList = [];
						contractCtrls.forEach(function (contractctrl, index) {
							var oldContract = contractctrl.getContract();
							if (contract !== oldContract && !contractctrl.isFinished()) {
								setNotBroadcastable();
							}
						});
						if (broadcastable) {
							$rootScope.$broadcast("contract:finished", contract);
						}
						setNotBroadcastable();
					}
				}
			}
		};

		return {
			getBroadcastable: getBroadcastable,
			setNotBroadcastable: setNotBroadcastable,
			isFinished: isFinished,
			getContract: getContract,
			isSpot: isSpot,
			betweenExistingSpots: betweenExistingSpots,
			resetSpotShowing: resetSpotShowing,
			addSpots: addSpots,
			addRegions: addRegions,
			viewSpots: viewSpots,
			viewRegions: viewRegions,
			getEntrySpotPoint: getEntrySpotPoint,
			getExitSpotPoint: getExitSpotPoint
		};
	};

	var ChartDrawer = function ChartDrawer() {
		var dataIndex = 0,
		    canvas,
		    ctx,
		    dragging = false,
		    zooming = false,
		    stepper = Stepper();

		var isLastPoint = function isLastPoint(i) {
			if (reversedIndex(i) === 0) {
				return true;
			} else {
				return false;
			}
		};

		var hideLabels = function hideLabels() {
			if (chartGlobals.tickCount >= chartGlobals.hideLabelsThreshold) {
				return true;
			} else {
				return false;
			}
		};

		var showingHistory = function showingHistory() {
			if (dataIndex === 0) {
				return false;
			} else {
				return true;
			}
		};

		var getLabelColor = function getLabelColor(index) {
			var color = 'black';
			if (!showingHistory() && isLastPoint(index)) {
				color = '#2E8836';
			}
			contractCtrls.forEach(function (contract) {
				if (contract.isSpot(index)) {
					color = '#818183';
				}
			});
			return color;
		};

		var getDotColor = function getDotColor(value, index) {
			var color;
			contractCtrls.forEach(function (contract) {
				if (contract.betweenExistingSpots(value)) {
					color = '#7cb5ec';
				}
			});
			if (utils.isDefined(color)) {
				return color;
			}
			if (isLastPoint(index) && !showingHistory()) {
				color = '#2E8836';
			} else {
				color = '#7cb5ec';
			}
			return color;
		};

		var drawRegion = function drawRegion(thisChart, region) {
			var height = thisChart.scale.endPoint - thisChart.scale.startPoint + 12,
			    // + 12 to size up the region to the top
			length,
			    end,
			    start;

			start = thisChart.datasets[0].points[region.start].x;
			if (utils.isDefined(region.end)) {
				end = thisChart.datasets[0].points[region.end].x;
			} else {
				end = thisChart.datasets[0].points.slice(-1)[0].x;
			}
			if (end <= start) {
				return;
			}
			length = end - start;
			ctx.fillStyle = region.color;
			ctx.fillRect(start, thisChart.scale.startPoint - 12, length, height); // begin the region from the top
		};

		var getLabelSize = function getLabelSize(ctx, point) {
			return {
				width: ctx.measureText(point.value).width,
				height: parseInt(ctx.font)
			};
		};

		var overlapping = function overlapping(point1, point2) {
			return point1.s < point2.e && point1.e > point2.s || point2.s < point1.e && point2.e > point1.s;
		};

		var overlapping2d = function overlapping2d(point1, point2) {
			var point1Size = getLabelSize(ctx, point1);
			var point2Size = getLabelSize(ctx, point2);
			var overlappingY = overlapping({
				s: point1.y,
				e: point1.y + point1Size.height
			}, {
				s: point2.y,
				e: point2.y + point2Size.height
			});
			var overlappingX = overlapping({
				s: point1.x,
				e: point1.x + point1Size.width
			}, {
				s: point2.x,
				e: point2.x + point2Size.width
			});
			return overlappingX && overlappingY;
		};

		var findSpots = function findSpots(points) {
			var entries = [],
			    exits = [];
			contractCtrls.forEach(function (contract) {
				var entry, exit;
				entry = contract.getEntrySpotPoint(points);
				exit = contract.getExitSpotPoint(points);
				if (utils.isDefined(entry)) {
					entries.push(entry);
				}
				if (utils.isDefined(exit)) {
					exits.push(exit);
				}
			});
			return {
				entries: entries,
				exits: exits
			};
		};

		var withoutConflict = function withoutConflict(toShow, point) {
			var result = true;
			toShow.forEach(function (toShowPoint, index) {
				if (overlapping2d(toShowPoint, point)) {
					result = false;
				}
			});
			return result;
		};

		var toShowLabels = function toShowLabels(points) {
			var toShow = [];
			var spots = findSpots(points);
			// This is our priority: 1. exit spot, 2. entry spot, 3. last value, 4. others (right to left)

			spots.exits.forEach(function (exit, index) {
				toShow.push(exit);
			});

			spots.entries.forEach(function (entry, index) {
				if (withoutConflict(toShow, entry)) {
					toShow.push(entry);
				}
			});

			var lastPoint = points.slice(-1)[0];
			if (!showingHistory() && withoutConflict(toShow, lastPoint)) {
				toShow.push(lastPoint);
			}
			// add other labels from right to left
			if (!hideLabels()) {
				for (var i = points.length - 1; i >= 0; i--) {
					if (withoutConflict(toShow, points[i])) {
						toShow.push(points[i]);
					}
				}
			}
			toShow.forEach(function (toShowPoint, index) {
				toShowPoint.shown = true;
			});
		};

		var drawLabel = function drawLabel(point, index) {
			if (index !== 0 && utils.isDefined(point.shown) && point.shown) {
				ctx.fillStyle = getLabelColor(index);
				ctx.textAlign = "center";
				ctx.textBaseline = "bottom";

				var padding = 0;
				var valueWidth = getLabelSize(ctx, point).width;
				if (isLastPoint(index)) {
					padding = valueWidth < 45 ? 0 : valueWidth - 45;
				}
				ctx.fillText(point.value, point.x - padding, point.y - 1);
			}
		};

		var drawGridLine = function drawGridLine(thisChart, gridLine) {
			var point = thisChart.datasets[0].points[gridLine.index];
			var scale = thisChart.scale;

			ctx.beginPath();
			if (gridLine.orientation === 'vertical') {
				ctx.moveTo(point.x, scale.startPoint + 24);
				ctx.strokeStyle = gridLine.color;
				ctx.fillStyle = gridLine.color;
				ctx.lineTo(point.x, scale.endPoint);
				ctx.stroke();

				ctx.textAlign = 'center';
				ctx.fillText(gridLine.label, point.x, scale.startPoint + 12);
			} else if (gridLine.orientation === 'horizontal') {
				var yPoint = point.y;
				if (gridLine.type === 'average' && gridLine.index !== gridLine.firstIndex) {
					var firstPoint = thisChart.datasets[0].points[gridLine.firstIndex];
					yPoint = (firstPoint.y + point.y) / 2;
				}

				ctx.moveTo(scale.startPoint, yPoint);

				ctx.strokeStyle = gridLine.color;
				ctx.fillStyle = gridLine.color;
				ctx.lineTo(thisChart.chart.width, yPoint);
				ctx.stroke();

				ctx.textAlign = 'center';
				var labelWidth = ctx.measureText(gridLine.label).width;
				ctx.fillText(gridLine.label, parseInt(labelWidth / 2) + 5, yPoint - 1);
			}
		};

		/* Override ChartJS Defaults */
		Chart.CustomScale = Chart.Scale.extend({
			initialize: function initialize() {
				var longestText = function longestText(ctx, font, arrayOfStrings) {
					ctx.font = font;
					var longest = 0;
					Chart.helpers.each(arrayOfStrings, function (string) {
						var textWidth = ctx.measureText(string).width;
						longest = textWidth > longest ? textWidth : longest;
					});
					return longest;
				};

				this.calculateXLabelRotation = function () {

					this.ctx.font = this.font;

					var lastWidth = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width;

					this.xScalePaddingRight = lastWidth / 2 + 3;

					this.xLabelRotation = 0;
					if (this.display) {
						var originalLabelWidth = longestText(this.ctx, this.font, this.xLabels);
						this.xLabelWidth = originalLabelWidth;
					} else {
						this.xLabelWidth = 0;
						this.xScalePaddingRight = this.padding;
					}
					this.xScalePaddingLeft = 0;
				};
				Chart.Scale.prototype.initialize.apply(this, arguments);
			},
			draw: function draw() {
				var helpers = Chart.helpers;
				var each = helpers.each;
				var aliasPixel = helpers.aliasPixel;
				var ctx = this.ctx,
				    yLabelGap = (this.endPoint - this.startPoint) / this.steps,
				    xStart = Math.round(this.xScalePaddingLeft);
				if (this.display) {
					ctx.fillStyle = this.textColor;
					ctx.font = this.font;
					each(this.yLabels, function (labelString, index) {
						var yLabelCenter = this.endPoint - yLabelGap * index,
						    linePositionY = Math.round(yLabelCenter);

						ctx.textAlign = "right";
						ctx.textBaseline = "middle";
						if (this.showLabels) {
							ctx.fillText(labelString, xStart - 10, yLabelCenter);
						}
						ctx.beginPath();
						if (index > 0) {
							ctx.lineWidth = this.gridLineWidth;
							ctx.strokeStyle = this.gridLineColor;
						} else {
							ctx.lineWidth = this.lineWidth;
							ctx.strokeStyle = this.lineColor;
						}

						linePositionY += helpers.aliasPixel(ctx.lineWidth);

						ctx.moveTo(xStart, linePositionY);
						ctx.lineTo(this.width, linePositionY);
						ctx.stroke();
						ctx.closePath();

						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;
						ctx.beginPath();
						ctx.moveTo(xStart - 5, linePositionY);
						ctx.lineTo(xStart, linePositionY);
						ctx.stroke();
						ctx.closePath();
					}, this);

					each(this.xLabels, function (label, index) {
						var filtered = false;
						if (typeof this.labelsFilter === "function" && this.labelsFilter(index)) {
							filtered = true;
						}
						var xPos = this.calculateX(index) + aliasPixel(this.lineWidth),
						    linePos = this.calculateX(index - (this.offsetGridLines ? 0.5 : 0)) + aliasPixel(this.lineWidth);

						ctx.beginPath();

						if (index > 0) {
							ctx.lineWidth = this.gridLineWidth;
							ctx.strokeStyle = this.gridLineColor;
						} else {
							ctx.lineWidth = this.lineWidth;
							ctx.strokeStyle = this.lineColor;
						}
						ctx.moveTo(linePos, this.endPoint);
						ctx.lineTo(linePos, this.startPoint - 12);
						ctx.stroke();
						ctx.closePath();

						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;

						ctx.beginPath();
						ctx.moveTo(linePos, this.endPoint);
						if (filtered) {
							ctx.lineTo(linePos, this.endPoint);
						} else {
							ctx.lineTo(linePos, this.endPoint + 5);
						}
						ctx.stroke();
						ctx.closePath();

						ctx.save();
						ctx.translate(xPos, this.endPoint + 8);

						ctx.textAlign = "center";
						ctx.textBaseline = "top";
						if (!filtered) {
							ctx.fillText(label, 0, 0);
						}
						ctx.restore();
					}, this);
				}
			}
		});

		Chart.types.Line.extend({
			name: "LineChartSpots",
			initialize: function initialize(data) {
				this.options.labelsFilter = data.labelsFilter || null;
				Chart.types.Line.prototype.initialize.apply(this, arguments);
			},
			draw: function draw() {
				var dataset = this.datasets[0];
				var thisChart = this;

				dataset.points.forEach(function (point, index) {
					point.fillColor = getDotColor(chartGlobals.chartData.epochLabels[index], index);
				});

				Chart.types.Line.prototype.draw.apply(this, arguments);
				toShowLabels(dataset.points);
				dataset.points.forEach(function (point, index) {
					drawLabel(point, index);
				});

				if (utils.isDefined(this.options.regions)) {
					this.options.regions.forEach(function (region) {
						drawRegion(thisChart, region);
					});
				}

				if (utils.isDefined(this.options.gridLines)) {
					this.options.gridLines.forEach(function (gridLine) {
						drawGridLine(thisChart, gridLine);
					});
				}
			},
			buildScale: function buildScale(labels) {
				var helpers = Chart.helpers;
				var self = this;

				var dataTotal = function dataTotal() {
					var values = [];
					self.eachPoints(function (point) {
						values.push(point.value);
					});

					return values;
				};
				var scaleOptions = {
					templateString: this.options.scaleLabel,
					height: this.chart.height,
					width: this.chart.width,
					ctx: this.chart.ctx,
					textColor: this.options.scaleFontColor,
					fontSize: this.options.scaleFontSize,
					labelsFilter: this.options.labelsFilter,
					fontStyle: this.options.scaleFontStyle,
					fontFamily: this.options.scaleFontFamily,
					valuesCount: labels.length,
					beginAtZero: this.options.scaleBeginAtZero,
					integersOnly: this.options.scaleIntegersOnly,
					calculateYRange: function calculateYRange(currentHeight) {
						var updatedRanges = helpers.calculateScaleRange(dataTotal(), currentHeight, this.fontSize, this.beginAtZero, this.integersOnly);
						helpers.extend(this, updatedRanges);
					},
					xLabels: labels,
					font: helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
					lineWidth: this.options.scaleLineWidth,
					lineColor: this.options.scaleLineColor,
					gridLineWidth: this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0,
					gridLineColor: this.options.scaleShowGridLines ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
					padding: this.options.showScale ? 0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth,
					showLabels: this.options.scaleShowLabels,
					display: this.options.showScale
				};

				if (this.options.scaleOverride) {
					helpers.extend(scaleOptions, {
						calculateYRange: helpers.noop,
						steps: this.options.scaleSteps,
						stepValue: this.options.scaleStepWidth,
						min: this.options.scaleStartValue,
						max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth
					});
				}

				this.scale = new Chart.CustomScale(scaleOptions);
			}
		});
		/* End of Override ChartJS Defaults */

		var destroy = function destroy() {
			chartGlobals.chartJS.destroy();
			setChartGlobals();
			canvas = null;
			ctx = null;
			dataIndex = 0;
			dragging = false;
			zooming = false;
			stepper = null;
		};

		var drawChart = function drawChart(chartID) {
			canvas = document.getElementById(chartID);
			if (canvas !== null) {
				ctx = canvas.getContext('2d');
				stepper = Stepper();
				stepper.setDistance(canvas, chartGlobals.tickCount);
			}
		};

		var findRegion = function findRegion(region) {
			if (utils.isDefined(chartGlobals.chartOptions.regions)) {
				return chartGlobals.chartOptions.regions.indexOf(region);
			} else {
				return -1;
			}
		};

		var addRegion = function addRegion(region) {
			if (!utils.isDefined(chartGlobals.chartOptions.regions)) {
				chartGlobals.chartOptions.regions = [];
			}
			if (findRegion(region) < 0) {
				chartGlobals.chartOptions.regions.push(region);
			}
		};

		var removeRegion = function removeRegion(region) {
			var regionIndex = findRegion(region);
			if (regionIndex >= 0) {
				chartGlobals.chartOptions.regions.splice(regionIndex, 1);
			}
		};

		var dragStart = function dragStart(e) {
			stepper.setStartPosition(dataIndex, e.center.x);
			dragging = true;
		};

		var dragEnd = function dragEnd(e) {
			if (!zooming) {
				move(stepper.stepCount(dataIndex, e.center.x));
			}
			stepper.stop();
			dragging = false;
		};

		var zoomStart = function zoomStart() {
			zooming = true;
		};

		var zoomEnd = function zoomEnd() {
			zooming = false;
		};

		var addGridLine = function addGridLine(gridLine) {
			if (!utils.isDefined(chartGlobals.chartOptions.gridLines)) {
				chartGlobals.chartOptions.gridLines = [];
			}
			chartGlobals.chartOptions.gridLines.push(gridLine);
		};

		var updateChartPoints = function updateChartPoints(times, values) {
			chartGlobals.chartData.labels = [];
			chartGlobals.chartData.epochLabels = times;
			times.forEach(function (time, index) {
				chartGlobals.chartData.labels.push(utils.getTickTime(time));
			});

			chartGlobals.chartData.datasets[0].data = values;
			if (utils.isDefined(chartGlobals.chartJS)) {
				chartGlobals.chartJS.destroy();
			}
			if (utils.isDefined(ctx)) {
				var chartObj = new Chart(ctx);
				chartGlobals.chartJS = chartObj.LineChartSpots(chartGlobals.chartData, chartGlobals.chartOptions);
			}
		};

		// depends on updateContracts call
		var updateChart = function updateChart(ticks) {
			chartGlobals.chartOptions.gridLines = [];
			contractCtrls.forEach(function (contract) {
				contract.resetSpotShowing();
			});
			var times = [],
			    prices = [];

			ticks.forEach(function (tick, index) {
				var tickTime = parseInt(tick.time);
				contractCtrls.forEach(function (contract) {
					contract.viewSpots(index, tickTime);
				});
				times.push(tickTime);
				prices.push(tick.price);
			});

			contractCtrls.forEach(function (contract) {
				contract.viewRegions();
			});

			updateChartPoints(times, prices);
		};

		var updateContracts = function updateContracts(ticks) {
			var lastTime, lastPrice;

			ticks.forEach(function (tick, index) {
				var tickTime = parseInt(tick.time);
				var tickPrice = tick.price;
				contractCtrls.forEach(function (contract) {
					contract.addSpots(index, tickTime, tickPrice);
				});
				lastTime = parseInt(tick.time);
				lastPrice = tick.price;
			});

			contractCtrls.forEach(function (contract) {
				contract.addRegions(lastTime, lastPrice);
			});
		};

		var addTick = function addTick(tick) {
			if (utils.isDefined(localHistory)) {
				localHistory.addTick(tick);
				localHistory.getHistory(0, chartGlobals.capacity, updateContracts);
				if (dataIndex === 0 && !dragging && !zooming) {
					localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
				} else {
					move(1, false);
				}
			}
		};

		var addHistory = function addHistory(history) {
			if (!utils.isDefined(localHistory)) {
				localHistory = LocalHistory(chartGlobals.capacity);
			}
			localHistory.addHistory(history);
			localHistory.getHistory(0, chartGlobals.capacity, updateContracts);
			localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
		};

		var addCandles = function addCandles(candles) {};

		var addOhlc = function addOhlc(ohlc) {};

		var zoom = function zoom(direction) {
			var newTickCount;
			var condition;
			if (direction === 'in') {
				newTickCount = parseInt(chartGlobals.tickCount / 1.2);
				condition = newTickCount > chartGlobals.minTickCount;
			} else if (direction === 'out') {
				newTickCount = parseInt(chartGlobals.tickCount * 1.2);
				condition = newTickCount < chartGlobals.maxTickCount;
			} else {
				return;
			}
			if (condition) {
				chartGlobals.tickCount = newTickCount;
				localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
				stepper.setDistance(canvas, chartGlobals.tickCount);
			}
		};

		var zoomOut = function zoomOut() {
			zoom('out');
		};

		var zoomIn = function zoomIn() {
			zoom('in');
		};

		var move = function move(steps, update) {
			if (steps === 0) {
				return;
			}
			var testDataIndex = dataIndex + steps;
			if (testDataIndex < 0) {
				// overflow
				testDataIndex = 0;
			} else if (testDataIndex >= chartGlobals.capacity - chartGlobals.tickCount) {
				// underflow
				testDataIndex = chartGlobals.capacity - chartGlobals.tickCount - 1;
			}
			if (testDataIndex !== dataIndex) {
				dataIndex = testDataIndex;
				if (!utils.isDefined(update) || update) {
					localHistory.getHistory(dataIndex, chartGlobals.tickCount, updateChart);
				}
			}
		};

		var drag = function drag(e) {
			if (!zooming && stepper.isStep(e, chartGlobals.tickCount)) {
				move(stepper.stepCount(dataIndex, e.center.x));
			}
		};

		var getCapacity = function getCapacity() {
			return chartGlobals.capacity;
		};

		var getTickCount = function getTickCount() {
			return chartGlobals.tickCount;
		};

		var getDataIndex = function getDataIndex() {
			return dataIndex;
		};

		var addContract = function addContract(_contract) {
			if (_contract) {
				if (utils.digitTrade(_contract) || utils.asianGame(_contract)) {
					_contract.duration -= 1;
				}
				contractCtrls.push(ContractCtrl(_contract));
				dataIndex = 0;
			}
		};

		var historyInterface = {
			addTick: addTick,
			addHistory: addHistory,
			addCandles: addCandles,
			addOhlc: addOhlc
		};

		return {
			dragStart: dragStart,
			dragEnd: dragEnd,
			zoomIn: zoomIn,
			zoomOut: zoomOut,
			zoomStart: zoomStart,
			zoomEnd: zoomEnd,
			dragRight: drag,
			dragLeft: drag,
			getCapacity: getCapacity,
			getTickCount: getTickCount,
			getDataIndex: getDataIndex,
			addContract: addContract,
			historyInterface: historyInterface,
			addGridLine: addGridLine,
			addRegion: addRegion,
			removeRegion: removeRegion,
			drawChart: drawChart,
			destroy: destroy
		};
	};

	var drawChart = function drawChart(chartID) {
		chartDrawer.drawChart(chartID);
	};

	var destroy = function destroy() {
		chartDrawer.destroy();
		contractCtrls.forEach(function (contractctrl, index) {
			contractctrl.setNotBroadcastable();
		});
		localHistory = null;
	};

	chartDrawer = ChartDrawer();

	return {
		destroy: destroy,
		drawChart: drawChart,
		dragStart: chartDrawer.dragStart,
		dragEnd: chartDrawer.dragEnd,
		zoomIn: chartDrawer.zoomIn,
		zoomOut: chartDrawer.zoomOut,
		zoomStart: chartDrawer.zoomStart,
		zoomEnd: chartDrawer.zoomEnd,
		dragRight: chartDrawer.dragRight,
		dragLeft: chartDrawer.dragLeft,
		getCapacity: chartDrawer.getCapacity,
		addContract: chartDrawer.addContract,
		historyInterface: chartDrawer.historyInterface
	};
}]);
'use strict';

/**
 * @name cleanupService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/22/2015
 * @copyright Binary Ltd
 *
 */

angular.module('binary').service('cleanupService', ["$translate", "proposalService", function ($translate, proposalService) {

  this.run = function () {
    proposalService.forget();
  };
}]);
'use strict';

/**
 * @name delayService
 * @author Amin Marashi
 * @contributors []
 * @since 01/21/2016
 * @copyright Binary Ltd
 *
 */

angular.module('binary').factory('delayService', function () {
	var functions = {};
	var runTimestamps = {};
	var FunctionController = function FunctionController(delayedFunction, args, name) {
		var timeoutId = 0;
		return {
			run: function run(minimumDelay) {
				var runFunc = function runFunc() {
					runTimestamps[name] = new Date().getTime();
					delayedFunction.apply(this, args);
				};

				if (minimumDelay !== 0) {
					timeoutId = setTimeout(function () {
						runFunc();
					}, minimumDelay);
				} else {
					runFunc();
				}
			},
			cancel: function cancel() {
				clearTimeout(timeoutId);
			}
		};
	};
	return {
		update: function update(name, delayedFunction, minimumDelay, args) {
			var now = new Date().getTime();
			if (functions.hasOwnProperty(name)) {
				var remainingTime = minimumDelay - (now - runTimestamps[name]);
				if (remainingTime > 0) {
					minimumDelay = remainingTime;
				} else {
					minimumDelay = 0;
				}
				functions[name].cancel();
			} else {
				minimumDelay = 0;
				runTimestamps[name] = now;
			}
			functions[name] = FunctionController(delayedFunction, args, name);
			functions[name].run(minimumDelay);
		},
		remove: function remove(name) {
			if (functions.hasOwnProperty(name)) {
				functions[name].cancel();
				delete functions[name];
				delete runTimestamps[name];
			}
		}
	};
});
'use strict';

/**
 * @name languageService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/26/2015
 * @copyright Binary Ltd
 *
 */

angular.module('binary').service('languageService', ["$rootScope", "$translate", "cleanupService", function ($rootScope, $translate, cleanupService) {

	/**
  * Update default language in local storage
  * Changes the app language
  * @param  {String} _language [description]
  */
	this.update = function (_language) {
		localStorage.language = _language;
		this.set(_language);
	};

	/**
  * Read the language from local storage
  * if exists update the app's language
  */
	this.set = function (_language) {
		if (!_language) {
			var language = localStorage.language || 'en';
		} else {
			var language = _language;
		}
		cleanupService.run();
		$rootScope.$broadcast('language:updated');
		$translate.use(language);
	};

	this.read = function () {
		var language = localStorage['language'];
		return language ? language : 'en';
	};

	this.remove = function () {
		localStorage.removeItem('language');
		cleanupService.run();
	};

	var isoLangs = {
		"ab": {
			"name": "Abkhaz",
			"nativeName": "аҧсуа"
		},
		"aa": {
			"name": "Afar",
			"nativeName": "Afaraf"
		},
		"af": {
			"name": "Afrikaans",
			"nativeName": "Afrikaans"
		},
		"ak": {
			"name": "Akan",
			"nativeName": "Akan"
		},
		"sq": {
			"name": "Albanian",
			"nativeName": "Shqip"
		},
		"am": {
			"name": "Amharic",
			"nativeName": "አማርኛ"
		},
		"ar": {
			"name": "Arabic",
			"nativeName": "العربية"
		},
		"an": {
			"name": "Aragonese",
			"nativeName": "Aragonés"
		},
		"hy": {
			"name": "Armenian",
			"nativeName": "Հայերեն"
		},
		"as": {
			"name": "Assamese",
			"nativeName": "অসমীয়া"
		},
		"av": {
			"name": "Avaric",
			"nativeName": "авар мацӀ, магӀарул мацӀ"
		},
		"ae": {
			"name": "Avestan",
			"nativeName": "avesta"
		},
		"ay": {
			"name": "Aymara",
			"nativeName": "aymar aru"
		},
		"az": {
			"name": "Azerbaijani",
			"nativeName": "azərbaycan dili"
		},
		"bm": {
			"name": "Bambara",
			"nativeName": "bamanankan"
		},
		"ba": {
			"name": "Bashkir",
			"nativeName": "башҡорт теле"
		},
		"eu": {
			"name": "Basque",
			"nativeName": "euskara, euskera"
		},
		"be": {
			"name": "Belarusian",
			"nativeName": "Беларуская"
		},
		"bn": {
			"name": "Bengali",
			"nativeName": "বাংলা"
		},
		"bh": {
			"name": "Bihari",
			"nativeName": "भोजपुरी"
		},
		"bi": {
			"name": "Bislama",
			"nativeName": "Bislama"
		},
		"bs": {
			"name": "Bosnian",
			"nativeName": "bosanski jezik"
		},
		"br": {
			"name": "Breton",
			"nativeName": "brezhoneg"
		},
		"bg": {
			"name": "Bulgarian",
			"nativeName": "български език"
		},
		"my": {
			"name": "Burmese",
			"nativeName": "ဗမာစာ"
		},
		"ca": {
			"name": "Catalan; Valencian",
			"nativeName": "Català"
		},
		"ch": {
			"name": "Chamorro",
			"nativeName": "Chamoru"
		},
		"ce": {
			"name": "Chechen",
			"nativeName": "нохчийн мотт"
		},
		"ny": {
			"name": "Chichewa; Chewa; Nyanja",
			"nativeName": "chiCheŵa, chinyanja"
		},
		"zh": {
			"name": "Chinese",
			"nativeName": "中文 (Zhōngwén), 汉语, 漢語"
		},
		"cv": {
			"name": "Chuvash",
			"nativeName": "чӑваш чӗлхи"
		},
		"kw": {
			"name": "Cornish",
			"nativeName": "Kernewek"
		},
		"co": {
			"name": "Corsican",
			"nativeName": "corsu, lingua corsa"
		},
		"cr": {
			"name": "Cree",
			"nativeName": "ᓀᐦᐃᔭᐍᐏᐣ"
		},
		"hr": {
			"name": "Croatian",
			"nativeName": "hrvatski"
		},
		"cs": {
			"name": "Czech",
			"nativeName": "česky, čeština"
		},
		"da": {
			"name": "Danish",
			"nativeName": "dansk"
		},
		"dv": {
			"name": "Divehi; Dhivehi; Maldivian;",
			"nativeName": "ދިވެހި"
		},
		"nl": {
			"name": "Dutch",
			"nativeName": "Nederlands, Vlaams"
		},
		"en": {
			"name": "English",
			"nativeName": "English"
		},
		"eo": {
			"name": "Esperanto",
			"nativeName": "Esperanto"
		},
		"et": {
			"name": "Estonian",
			"nativeName": "eesti, eesti keel"
		},
		"ee": {
			"name": "Ewe",
			"nativeName": "Eʋegbe"
		},
		"fo": {
			"name": "Faroese",
			"nativeName": "føroyskt"
		},
		"fj": {
			"name": "Fijian",
			"nativeName": "vosa Vakaviti"
		},
		"fi": {
			"name": "Finnish",
			"nativeName": "suomi, suomen kieli"
		},
		"fr": {
			"name": "French",
			"nativeName": "français, langue française"
		},
		"ff": {
			"name": "Fula; Fulah; Pulaar; Pular",
			"nativeName": "Fulfulde, Pulaar, Pular"
		},
		"gl": {
			"name": "Galician",
			"nativeName": "Galego"
		},
		"ka": {
			"name": "Georgian",
			"nativeName": "ქართული"
		},
		"de": {
			"name": "German",
			"nativeName": "Deutsch"
		},
		"el": {
			"name": "Greek, Modern",
			"nativeName": "Ελληνικά"
		},
		"gn": {
			"name": "Guaraní",
			"nativeName": "Avañeẽ"
		},
		"gu": {
			"name": "Gujarati",
			"nativeName": "ગુજરાતી"
		},
		"ht": {
			"name": "Haitian; Haitian Creole",
			"nativeName": "Kreyòl ayisyen"
		},
		"ha": {
			"name": "Hausa",
			"nativeName": "Hausa, هَوُسَ"
		},
		"he": {
			"name": "Hebrew (modern)",
			"nativeName": "עברית"
		},
		"hz": {
			"name": "Herero",
			"nativeName": "Otjiherero"
		},
		"hi": {
			"name": "Hindi",
			"nativeName": "हिन्दी, हिंदी"
		},
		"ho": {
			"name": "Hiri Motu",
			"nativeName": "Hiri Motu"
		},
		"hu": {
			"name": "Hungarian",
			"nativeName": "Magyar"
		},
		"ia": {
			"name": "Interlingua",
			"nativeName": "Interlingua"
		},
		"id": {
			"name": "Indonesian",
			"nativeName": "Bahasa Indonesia"
		},
		"ie": {
			"name": "Interlingue",
			"nativeName": "Originally called Occidental; then Interlingue after WWII"
		},
		"ga": {
			"name": "Irish",
			"nativeName": "Gaeilge"
		},
		"ig": {
			"name": "Igbo",
			"nativeName": "Asụsụ Igbo"
		},
		"ik": {
			"name": "Inupiaq",
			"nativeName": "Iñupiaq, Iñupiatun"
		},
		"io": {
			"name": "Ido",
			"nativeName": "Ido"
		},
		"is": {
			"name": "Icelandic",
			"nativeName": "Íslenska"
		},
		"it": {
			"name": "Italian",
			"nativeName": "Italiano"
		},
		"iu": {
			"name": "Inuktitut",
			"nativeName": "ᐃᓄᒃᑎᑐᑦ"
		},
		"ja": {
			"name": "Japanese",
			"nativeName": "日本語 (にほんご／にっぽんご)"
		},
		"jv": {
			"name": "Javanese",
			"nativeName": "basa Jawa"
		},
		"kl": {
			"name": "Kalaallisut, Greenlandic",
			"nativeName": "kalaallisut, kalaallit oqaasii"
		},
		"kn": {
			"name": "Kannada",
			"nativeName": "ಕನ್ನಡ"
		},
		"kr": {
			"name": "Kanuri",
			"nativeName": "Kanuri"
		},
		"ks": {
			"name": "Kashmiri",
			"nativeName": "कश्मीरी, كشميري‎"
		},
		"kk": {
			"name": "Kazakh",
			"nativeName": "Қазақ тілі"
		},
		"km": {
			"name": "Khmer",
			"nativeName": "ភាសាខ្មែរ"
		},
		"ki": {
			"name": "Kikuyu, Gikuyu",
			"nativeName": "Gĩkũyũ"
		},
		"rw": {
			"name": "Kinyarwanda",
			"nativeName": "Ikinyarwanda"
		},
		"ky": {
			"name": "Kirghiz, Kyrgyz",
			"nativeName": "кыргыз тили"
		},
		"kv": {
			"name": "Komi",
			"nativeName": "коми кыв"
		},
		"kg": {
			"name": "Kongo",
			"nativeName": "KiKongo"
		},
		"ko": {
			"name": "Korean",
			"nativeName": "한국어 (韓國語), 조선말 (朝鮮語)"
		},
		"ku": {
			"name": "Kurdish",
			"nativeName": "Kurdî, كوردی‎"
		},
		"kj": {
			"name": "Kwanyama, Kuanyama",
			"nativeName": "Kuanyama"
		},
		"la": {
			"name": "Latin",
			"nativeName": "latine, lingua latina"
		},
		"lb": {
			"name": "Luxembourgish, Letzeburgesch",
			"nativeName": "Lëtzebuergesch"
		},
		"lg": {
			"name": "Luganda",
			"nativeName": "Luganda"
		},
		"li": {
			"name": "Limburgish, Limburgan, Limburger",
			"nativeName": "Limburgs"
		},
		"ln": {
			"name": "Lingala",
			"nativeName": "Lingála"
		},
		"lo": {
			"name": "Lao",
			"nativeName": "ພາສາລາວ"
		},
		"lt": {
			"name": "Lithuanian",
			"nativeName": "lietuvių kalba"
		},
		"lu": {
			"name": "Luba-Katanga",
			"nativeName": ""
		},
		"lv": {
			"name": "Latvian",
			"nativeName": "latviešu valoda"
		},
		"gv": {
			"name": "Manx",
			"nativeName": "Gaelg, Gailck"
		},
		"mk": {
			"name": "Macedonian",
			"nativeName": "македонски јазик"
		},
		"mg": {
			"name": "Malagasy",
			"nativeName": "Malagasy fiteny"
		},
		"ms": {
			"name": "Malay",
			"nativeName": "bahasa Melayu, بهاس ملايو‎"
		},
		"ml": {
			"name": "Malayalam",
			"nativeName": "മലയാളം"
		},
		"mt": {
			"name": "Maltese",
			"nativeName": "Malti"
		},
		"mi": {
			"name": "Māori",
			"nativeName": "te reo Māori"
		},
		"mr": {
			"name": "Marathi (Marāṭhī)",
			"nativeName": "मराठी"
		},
		"mh": {
			"name": "Marshallese",
			"nativeName": "Kajin M̧ajeļ"
		},
		"mn": {
			"name": "Mongolian",
			"nativeName": "монгол"
		},
		"na": {
			"name": "Nauru",
			"nativeName": "Ekakairũ Naoero"
		},
		"nv": {
			"name": "Navajo, Navaho",
			"nativeName": "Diné bizaad, Dinékʼehǰí"
		},
		"nb": {
			"name": "Norwegian Bokmål",
			"nativeName": "Norsk bokmål"
		},
		"nd": {
			"name": "North Ndebele",
			"nativeName": "isiNdebele"
		},
		"ne": {
			"name": "Nepali",
			"nativeName": "नेपाली"
		},
		"ng": {
			"name": "Ndonga",
			"nativeName": "Owambo"
		},
		"nn": {
			"name": "Norwegian Nynorsk",
			"nativeName": "Norsk nynorsk"
		},
		"no": {
			"name": "Norwegian",
			"nativeName": "Norsk"
		},
		"ii": {
			"name": "Nuosu",
			"nativeName": "ꆈꌠ꒿ Nuosuhxop"
		},
		"nr": {
			"name": "South Ndebele",
			"nativeName": "isiNdebele"
		},
		"oc": {
			"name": "Occitan",
			"nativeName": "Occitan"
		},
		"oj": {
			"name": "Ojibwe, Ojibwa",
			"nativeName": "ᐊᓂᔑᓈᐯᒧᐎᓐ"
		},
		"cu": {
			"name": "Old Church Slavonic, Church Slavic, Church Slavonic, Old Bulgarian, Old Slavonic",
			"nativeName": "ѩзыкъ словѣньскъ"
		},
		"om": {
			"name": "Oromo",
			"nativeName": "Afaan Oromoo"
		},
		"or": {
			"name": "Oriya",
			"nativeName": "ଓଡ଼ିଆ"
		},
		"os": {
			"name": "Ossetian, Ossetic",
			"nativeName": "ирон æвзаг"
		},
		"pa": {
			"name": "Panjabi, Punjabi",
			"nativeName": "ਪੰਜਾਬੀ, پنجابی‎"
		},
		"pi": {
			"name": "Pāli",
			"nativeName": "पाऴि"
		},
		"fa": {
			"name": "Persian",
			"nativeName": "فارسی"
		},
		"pl": {
			"name": "Polish",
			"nativeName": "polski"
		},
		"ps": {
			"name": "Pashto, Pushto",
			"nativeName": "پښتو"
		},
		"pt": {
			"name": "Portuguese",
			"nativeName": "Português"
		},
		"qu": {
			"name": "Quechua",
			"nativeName": "Runa Simi, Kichwa"
		},
		"rm": {
			"name": "Romansh",
			"nativeName": "rumantsch grischun"
		},
		"rn": {
			"name": "Kirundi",
			"nativeName": "kiRundi"
		},
		"ro": {
			"name": "Romanian, Moldavian, Moldovan",
			"nativeName": "română"
		},
		"ru": {
			"name": "Russian",
			"nativeName": "русский язык"
		},
		"sa": {
			"name": "Sanskrit (Saṁskṛta)",
			"nativeName": "संस्कृतम्"
		},
		"sc": {
			"name": "Sardinian",
			"nativeName": "sardu"
		},
		"sd": {
			"name": "Sindhi",
			"nativeName": "सिन्धी, سنڌي، سندھی‎"
		},
		"se": {
			"name": "Northern Sami",
			"nativeName": "Davvisámegiella"
		},
		"sm": {
			"name": "Samoan",
			"nativeName": "gagana faa Samoa"
		},
		"sg": {
			"name": "Sango",
			"nativeName": "yângâ tî sängö"
		},
		"sr": {
			"name": "Serbian",
			"nativeName": "српски језик"
		},
		"gd": {
			"name": "Scottish Gaelic; Gaelic",
			"nativeName": "Gàidhlig"
		},
		"sn": {
			"name": "Shona",
			"nativeName": "chiShona"
		},
		"si": {
			"name": "Sinhala, Sinhalese",
			"nativeName": "සිංහල"
		},
		"sk": {
			"name": "Slovak",
			"nativeName": "slovenčina"
		},
		"sl": {
			"name": "Slovene",
			"nativeName": "slovenščina"
		},
		"so": {
			"name": "Somali",
			"nativeName": "Soomaaliga, af Soomaali"
		},
		"st": {
			"name": "Southern Sotho",
			"nativeName": "Sesotho"
		},
		"es": {
			"name": "Spanish; Castilian",
			"nativeName": "español, castellano"
		},
		"su": {
			"name": "Sundanese",
			"nativeName": "Basa Sunda"
		},
		"sw": {
			"name": "Swahili",
			"nativeName": "Kiswahili"
		},
		"ss": {
			"name": "Swati",
			"nativeName": "SiSwati"
		},
		"sv": {
			"name": "Swedish",
			"nativeName": "svenska"
		},
		"ta": {
			"name": "Tamil",
			"nativeName": "தமிழ்"
		},
		"te": {
			"name": "Telugu",
			"nativeName": "తెలుగు"
		},
		"tg": {
			"name": "Tajik",
			"nativeName": "тоҷикӣ, toğikī, تاجیکی‎"
		},
		"th": {
			"name": "Thai",
			"nativeName": "ไทย"
		},
		"ti": {
			"name": "Tigrinya",
			"nativeName": "ትግርኛ"
		},
		"bo": {
			"name": "Tibetan Standard, Tibetan, Central",
			"nativeName": "བོད་ཡིག"
		},
		"tk": {
			"name": "Turkmen",
			"nativeName": "Türkmen, Түркмен"
		},
		"tl": {
			"name": "Tagalog",
			"nativeName": "Wikang Tagalog, ᜏᜒᜃᜅ᜔ ᜆᜄᜎᜓᜄ᜔"
		},
		"tn": {
			"name": "Tswana",
			"nativeName": "Setswana"
		},
		"to": {
			"name": "Tonga (Tonga Islands)",
			"nativeName": "faka Tonga"
		},
		"tr": {
			"name": "Turkish",
			"nativeName": "Türkçe"
		},
		"ts": {
			"name": "Tsonga",
			"nativeName": "Xitsonga"
		},
		"tt": {
			"name": "Tatar",
			"nativeName": "татарча, tatarça, تاتارچا‎"
		},
		"tw": {
			"name": "Twi",
			"nativeName": "Twi"
		},
		"ty": {
			"name": "Tahitian",
			"nativeName": "Reo Tahiti"
		},
		"ug": {
			"name": "Uighur, Uyghur",
			"nativeName": "Uyƣurqə, ئۇيغۇرچە‎"
		},
		"uk": {
			"name": "Ukrainian",
			"nativeName": "українська"
		},
		"ur": {
			"name": "Urdu",
			"nativeName": "اردو"
		},
		"uz": {
			"name": "Uzbek",
			"nativeName": "zbek, Ўзбек, أۇزبېك‎"
		},
		"ve": {
			"name": "Venda",
			"nativeName": "Tshivenḓa"
		},
		"vi": {
			"name": "Vietnamese",
			"nativeName": "Tiếng Việt"
		},
		"vo": {
			"name": "Volapük",
			"nativeName": "Volapük"
		},
		"wa": {
			"name": "Walloon",
			"nativeName": "Walon"
		},
		"cy": {
			"name": "Welsh",
			"nativeName": "Cymraeg"
		},
		"wo": {
			"name": "Wolof",
			"nativeName": "Wollof"
		},
		"fy": {
			"name": "Western Frisian",
			"nativeName": "Frysk"
		},
		"xh": {
			"name": "Xhosa",
			"nativeName": "isiXhosa"
		},
		"yi": {
			"name": "Yiddish",
			"nativeName": "ייִדיש"
		},
		"yo": {
			"name": "Yoruba",
			"nativeName": "Yorùbá"
		},
		"za": {
			"name": "Zhuang, Chuang",
			"nativeName": "Saɯ cueŋƅ, Saw cuengh"
		},
		"zh_tw": {
			"name": "Chinese_tw",
			"nativeName": "繁體中文"
		},
		"zh_cn": {
			"name": "Chinese_cn",
			"nativeName": "简体中文"
		}
	};

	var getLanguageName = function getLanguageName(key) {
		var lang = isoLangs[key];
		return lang ? lang.name : undefined;
	};
	var getLanguageNativeName = function getLanguageNativeName(key) {
		var lang = isoLangs[key];
		return lang ? lang.nativeName : undefined;
	};
	this.getLanguageName = getLanguageName;
	this.getLanguageNativeName = getLanguageNativeName;
}]);
'use strict';

/**
 * @name cleanupService
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/31/2015
 * @copyright Binary Ltd
 *
 */

angular.module('binary').factory('localStorageService', ["$state", "appStateService", function ($state, appStateService) {
	var service = {};

	/**
  * find a {key,value} in an array of objects and return its index
  * returns -1 if not found
  * @param  {Array of Objects} _accounts
  * @param  {String} _key
  * @param  {String, Number, Boolean} _value
  * @return {Number} Index of the found array element
  */
	var findIndex = function findIndex(_accounts, _key, _value) {
		var index = -1;
		_accounts.forEach(function (el, i) {
			if (_accounts[i][_key] === _value) {
				index = i;
			}
		});
		return index;
	};

	service.removeToken = function removeToken(token) {
		if (localStorage.hasOwnProperty('accounts')) {
			var accounts = JSON.parse(localStorage.accounts);
			var tokenIndex = findIndex(accounts, 'token', token);
			if (tokenIndex > -1) {
				accounts.splice(tokenIndex);
				localStorage.accounts = JSON.stringify(accounts);
			}
		}
	};

	service.getDefaultToken = function () {
		if (localStorage.accounts && JSON.parse(localStorage.accounts) instanceof Array) {
			var accounts = JSON.parse(localStorage.accounts);
			var index = findIndex(accounts, 'is_default', true);
			if (index > -1) {
				return accounts[index].token;
			}
		}
		return null;
	};

	service.manageInvalidToken = function () {
		var defaultToken = service.getDefaultToken();
		if (defaultToken) {
			service.removeToken(defaultToken);
		}

		if (localStorage.hasOwnProperty('accounts')) {
			accounts = JSON.parse(localStorage.accounts);
			if (accounts.length) {
				accounts[0].is_default = true;
				localStorage.accounts = JSON.stringify(accounts);
				appStateService.invalidTokenRemoved = true;
				$state.go('accounts');
			} else {
				$state.go('signin');
			}
		} else {
			$state.go('signin');
		}
	};

	return service;
}]);
'use strict';

/**
 * @name tradeService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/15/2015
 * @copyright Binary Ltd
 * Handles websocket functionalities
 */

angular.module('binary').service('marketService', ["websocketService", "proposalService", "config", function (websocketService, proposalService, config) {

	var regroup = function regroup(symbols) {
		var groups = {
			index: ['R_100', 'R_25', 'R_50', 'R_75'],
			BEARBULL: ['RDBEAR', 'RDBULL'],
			MOONSUN: ['RDMOON', 'RDSUN'],
			MARSVENUS: ['RDMARS', 'RDVENUS'],
			YANGYIN: ['RDYANG', 'RDYIN']
		};

		var result = [],
		    itemIndices = [];
		Object.keys(groups).forEach(function (key) {
			var tmp = [],
			    first = -1;
			symbols.forEach(function (item, index) {
				if (item.symbol == groups[key][0]) {
					first = index;
				}
			});
			if (first < 0) {
				return;
			} else {
				groups[key].forEach(function (item, index) {
					var itemIndex = -1;
					symbols.forEach(function (item, i) {
						if (item.symbol == groups[key][index]) {
							itemIndex = i;
						}
					});
					if (itemIndex >= 0) {
						tmp.push(symbols[itemIndex]);
						itemIndices.push(itemIndex);
					}
				});
				tmp.sort();
				result = result.concat(tmp);
			}
		});
		symbols.forEach(function (symbol, index) {
			if (itemIndices.indexOf(index) < 0) {
				result.push(symbol);
			}
		});
		return result;
	};

	var reorder = function reorder(symbols) {
		symbols.sort(function (a, b) {
			if (a.display_name > b.display_name) {
				return 1;
			} else if (a.display_name < b.display_name) {
				return -1;
			}
			return 0;
		});
		symbols = regroup(symbols);
		return symbols;
	};

	this.fixOrder = function () {
		if (!sessionStorage.active_symbols || sessionStorage.active_symbols === 'null') {
			return;
		}

		var symbols = JSON.parse(sessionStorage.active_symbols);
		Object.keys(symbols).forEach(function (key) {
			symbols[key] = reorder(symbols[key]);
		});
		sessionStorage.active_symbols = JSON.stringify(symbols);
	};

	this.getActiveMarkets = function () {
		if (!sessionStorage.active_symbols || sessionStorage.active_symbols === "null") {
			return [];
		}

		var data = JSON.parse(sessionStorage.active_symbols);
		if (data) {
			return Object.keys(data);
		}

		console.log(data);
		return [];
	};

	this.getAllSymbolsForAMarket = function (_market) {
		if (!_market || !sessionStorage.active_symbols || !sessionStorage.asset_index) {
			return [];
		}

		var activeSymbols = JSON.parse(sessionStorage.active_symbols)[_market];
		var assetIndex = JSON.parse(sessionStorage.asset_index);
		var indexes = config.assetIndexes;
		var result = [];

		activeSymbols.map(function (market) {
			for (var i = 0; i < assetIndex.length; i++) {
				if (market.symbol === assetIndex[i][indexes.symbol]) {
					var assetContracts = assetIndex[i][indexes.contracts];
					for (var c = 0; c < assetContracts.length; c++) {
						if (assetContracts[c][indexes.contractFrom].indexOf('t') !== -1) {
							market.display_name = assetIndex[i][indexes.displayName];
							result.push(market);
							break;
						}
					}
					break; // do not loop through remained assets, since the related asset_index has been found but is not supporting ticks
				}
			}
			assetIndex.splice(i, 1); // to shorten the list for the next loop
		});

		return result;
	};

	this.getSymbolDetails = function (_symbol) {
		websocketService.sendRequestFor.contractsForSymbol(_symbol);
	};

	this.getDefault = {
		/**
   * Return the default/selected market
   * @return {String} Market Name
   */
		market: function market(_market) {
			var proposal = proposalService.get();
			if (proposal && proposal.passthrough && proposal.passthrough.market && _market[proposal.passthrough.market]) {

				return proposal.passthrough.market;
			}

			//return _market.random ? 'random' : 'forex';
			return _.findKey(_market, function (o) {
				return o;
			});
		},
		/**
   * Return the default/selected symbol
   * @return {String} Symbol Name
   */
		symbol: function symbol(_market, _symbols) {
			var proposal = proposalService.get();
			if (proposal && proposal.passthrough && proposal.passthrough.market && proposal.symbol && proposal.passthrough.market == _market) {

				return proposal.symbol;
			}
			return _symbols[0].symbol;
		},

		tradeType: function tradeType(_tradeTypes) {
			if (_.isEmpty(_tradeTypes)) {
				return null;
			}

			var proposal = proposalService.get();
			var contractType = proposal.contract_type;
			var selectedTradeType = _tradeTypes[0].value;
			_tradeTypes.forEach(function (el, i) {
				if (el.value == contractType) {
					selectedTradeType = contractType;
					return;
				}
			});
			return selectedTradeType;
		},

		tick: function tick() {
			var proposal = proposalService.get();
			return proposal.duration ? proposal.duration : 5;
		},

		digit: function digit() {
			var proposal = proposalService.get();
			return proposal.barrier ? proposal.barrier : 0;
		},

		basis: function basis() {
			var proposal = proposalService.get();
			return proposal.basis ? proposal.basis : 'payout';
		},

		amount: function amount() {
			var proposal = proposalService.get();
			if (!isNaN(proposal.amount)) {
				return proposal.amount;
			}
			return 5;
		}
	};

	this.getTradeTypes = function (_symbol) {
		var tradeTypes = config.tradeTypes;
		var finalTradeTypes = [];

		tradeTypes.forEach(function (el, i) {
			for (var key in _symbol) {
				if (_symbol.hasOwnProperty(key)) {
					// Find the tradeType in _symbol list
					if (el.value === key) {
						var hasTicks = false;
						// Loop through all _symbols of a trade type
						for (var j = 0; j < _symbol[key].length; j++) {
							var minDuration = _symbol[key][j].min_contract_duration;
							if (minDuration && minDuration.toString().match(/^\d+t$/)) {
								hasTicks = true;
							}
						}
						if (hasTicks) {
							finalTradeTypes.push(el);
						}
					}
				}
			}
		});

		return finalTradeTypes;
	};

	this.removeActiveSymbols = function () {
		sessionStorage.active_symbols = null;
	};

	this.removeAssetIndex = function () {
		sessionStorage.asset_index = null;
	};

	this.hasActiveSymobols = function () {
		if (!sessionStorage.active_symbols) return false;
		return JSON.parse(sessionStorage.active_symbols);
	};

	this.hasAssetIndex = function () {
		if (!sessionStorage.asset_index) return false;
		return JSON.parse(sessionStorage.asset_index);
	};
}]);
'use strict';

/**
 * @name tableStateService
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 05/02/2016
 * @copyright Binary Ltd
 * Keeping state of the app in this factory
 */

angular.module('binary').factory('tableStateService', function () {
    var factory = {};
    factory.dateType = 'allTime';
    factory.dateFrom = '';
    factory.dateTo = '';
    factory.currentPage = 0;
    factory.appID = 'allApps';
    factory.batchNum = 0;
    factory.batchLimit = 0;
    factory.batchSize = 20;
    factory.completedGroup = true;
    factory.statementDateType = 'allTime';
    factory.statementDateFrom = '';
    factory.statementDateTo = '';
    factory.statementCurrentPage = 0;
    factory.statementAppID = 'allApps';
    factory.statementBatchNum = 0;
    factory.statementBatchLimit = 0;
    factory.statementBatchSize = 20;
    factory.statementCompletedGroup = true;

    return factory;
});
'use strict';

/**
 * @name utils service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.services').factory('utilsService', Utils);

  Utils.$inject = ['$rootScope'];

  function Utils($rootScope) {
    var factory = {};

    factory.spinnerLogo = {
      start: function start() {
        $rootScope.$broadcast('spinner-logo:start');
      },
      stop: function stop() {
        $rootScope.$broadcast('spinner-logo:stop');
      }
    };

    return factory;
  }
})();
'use strict';

/**
 * @name websocketService
 * @author Massih Hazrati
 * @contributors []
 * @since 10/15/2015
 * @copyright Binary Ltd
 * Handles websocket functionalities
 */

angular.module('binary').factory('websocketService', ["$rootScope", "localStorageService", "alertService", "appStateService", "$state", "config", function ($rootScope, localStorageService, alertService, appStateService, $state, config) {
    var dataStream = '';
    var messageBuffer = [];

    var waitForConnection = function waitForConnection(callback, isAuthonticationRequest) {
        if (dataStream.readyState === 3) {
            init();
            if (!isAuthonticationRequest) {
                setTimeout(function () {
                    waitForConnection(callback);
                }, 1000);
            }
        } else if (dataStream.readyState === 1) {
            callback();
        } else if (!(dataStream instanceof WebSocket)) {
            init();
            if (!isAuthonticationRequest) {
                setTimeout(function () {
                    waitForConnection(callback);
                }, 1000);
            }
        } else {
            setTimeout(function () {
                waitForConnection(callback);
            }, 1000);
        }
    };

    var sendMessage = function sendMessage(_data) {
        var token = localStorageService.getDefaultToken();
        waitForConnection(function () {
            dataStream.send(JSON.stringify(_data));
        }, _data.hasOwnProperty('authorize') && token);
    };

    var init = function init(forced) {
        forced = forced || false;
        var language = localStorage.language || 'en';

        if (dataStream && dataStream.readyState !== 3 && !forced) {
            return;
        } else if (dataStream && dataStream.readyState !== 0) {
            dataStream.close();
        }

        dataStream = null;

        appStateService.isLoggedin = false;

        dataStream = new WebSocket(config.wsUrl + '?app_id=' + config.app_id + '&l=' + language);

        dataStream.onopen = function () {

            // Authorize the default token if it's exist
            var token = localStorageService.getDefaultToken();
            if (token) {
                var data = {
                    authorize: token,
                    passthrough: {
                        type: "reopen-connection"
                    }
                };
                sendMessage(data);
            }

            console.log('socket is opened');
            $rootScope.$broadcast('connection:ready');
        };

        dataStream.onmessage = function (message) {
            receiveMessage(message);
        };

        dataStream.onclose = function (e) {
            console.log('socket is closed ', e);
            init();
            console.log('socket is reopened');
            appStateService.isLoggedin = false;
            $rootScope.$broadcast('connection:reopened');
        };

        dataStream.onerror = function (e) {
            if (e.target.readyState == 3) {
                $rootScope.$broadcast('connection:error');
            }
            appStateService.isLoggedin = false;
        };
    };

    $rootScope.$on('language:updated', function () {
        init(true);
    });

    var websocketService = {};
    websocketService.authenticate = function (_token, extraParams) {
        extraParams = null || extraParams;
        appStateService.isLoggedin = false;

        var data = {
            authorize: _token
        };

        for (key in extraParams) {
            if (extraParams.hasOwnProperty(key)) {
                data[key] = extraParams[key];
            }
        }

        sendMessage(data);
    };

    websocketService.logout = function () {
        localStorage.removeItem('accounts');
        websocketService.sendRequestFor.forgetProposals();
        sessionStorage.active_symbols = null;
        sessionStorage.asset_index = null;
        appStateService.isRealityChecked = false;
        appStateService.isChangedAccount = false;
        appStateService.isPopupOpen = false;
        appStateService.isCheckedAccountType = false;
        appStateService.isLoggedin = false;
        sessionStorage.removeItem('start');
        sessionStorage.removeItem('_interval');
        localStorage.removeItem('termsConditionsVersion');
        appStateService.profitTableRefresh = true;
        appStateService.statementRefresh = true;
        appStateService.isNewAccountReal = false;
        appStateService.isNewAccountMaltainvest = false;
        appStateService.hasMLT = false;
        sessionStorage.removeItem('countryParams');
        websocketService.closeConnection();
        $state.go('signin');
    };

    websocketService.sendRequestFor = {
        websiteStatus: function websiteStatus() {
            var data = {
                "website_status": 1
            };
            sendMessage(data);
        },
        symbols: function symbols() {
            var data = {
                active_symbols: "brief"
            };
            sendMessage(data);
        },
        assetIndex: function assetIndex() {
            var data = {
                asset_index: 1
            };
            sendMessage(data);
        },
        currencies: function currencies() {
            var data = {
                payout_currencies: 1
            };
            sendMessage(data);
        },
        contractsForSymbol: function contractsForSymbol(_symbol) {
            var data = {
                contracts_for: _symbol
            };
            sendMessage(data);
        },
        ticksForSymbol: function ticksForSymbol(_symbol) {
            var data = {
                ticks: _symbol
            };
            sendMessage(data);
        },
        forgetAll: function forgetAll(_stream) {
            var data = {
                forget_all: _stream
            };
            sendMessage(data);
        },
        forgetStream: function forgetStream(_id) {
            var data = {
                forget: _id
            };
            sendMessage(data);
        },
        forgetProposals: function forgetProposals() {
            var data = {
                forget_all: 'proposal'
            };
            sendMessage(data);
        },
        forgetTicks: function forgetTicks() {
            var data = {
                forget_all: 'ticks'
            };
            sendMessage(data);
        },
        proposal: function proposal(_proposal) {
            sendMessage(_proposal);
        },
        purchase: function purchase(_proposalId, price) {
            var data = {
                buy: _proposalId,
                price: price || 0
            };
            sendMessage(data);
        },
        balance: function balance() {
            var data = {
                balance: 1,
                subscribe: 1
            };
            sendMessage(data);
        },
        portfolio: function portfolio() {
            var data = {
                portfolio: 1
            };
            sendMessage(data);
        },
        profitTable: function profitTable(params, req_id) {
            var data = {
                profit_table: 1
            };

            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    data[key] = params[key];
                }
            }

            sendMessage(data);
        },
        ticksHistory: function ticksHistory(data) {
            // data is the whole JSON convertable object parameter for the ticks_history API call
            if (data.ticks_history) {
                sendMessage(data);
            }
        },
        openContract: function openContract(contractId, extraParams) {
            var data = {};
            data.proposal_open_contract = 1;

            if (contractId) {
                data.contract_id = contractId;
            }

            for (var key in extraParams) {
                if (extraParams.hasOwnProperty(key)) {
                    data[key] = extraParams[key];
                }
            }

            sendMessage(data);
        },
        sellExpiredContract: function sellExpiredContract() {
            var data = {
                sell_expired: 1
            };

            sendMessage(data);
        },
        landingCompanyDetails: function landingCompanyDetails(company) {
            var data = {
                landing_company_details: company
            };
            sendMessage(data);
        },
        realityCheck: function realityCheck() {
            var data = {
                "reality_check": 1
            };
            sendMessage(data);
        },
        accountOpening: function accountOpening(verifyEmail) {
            var data = {
                "verify_email": verifyEmail,
                "type": "account_opening"
            };
            sendMessage(data);
        },
        residenceListSend: function residenceListSend() {
            var data = {
                "residence_list": 1
            };
            sendMessage(data);
        },
        newAccountVirtual: function newAccountVirtual(verificationCode, clientPassword, residence) {
            var data = {
                "new_account_virtual": "1",
                "verification_code": verificationCode,
                "client_password": clientPassword,
                "residence": residence
            };
            sendMessage(data);
        },
        accountSetting: function accountSetting() {
            var data = {
                "get_settings": 1
            };
            sendMessage(data);
        },
        setAccountSettings: function setAccountSettings(data) {
            data.set_settings = 1;

            sendMessage(data);
        },
        landingCompanySend: function landingCompanySend(company) {
            var data = {
                "landing_company": company
            };
            sendMessage(data);
        },
        statesListSend: function statesListSend(countryCode) {
            var data = {
                "states_list": countryCode
            };
            sendMessage(data);
        },
        createRealAccountSend: function createRealAccountSend(params) {
            var data = {
                "new_account_real": "1"
            };
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    data[key] = params[key];
                }
            };
            sendMessage(data);
        },
        createMaltainvestAccountSend: function createMaltainvestAccountSend(params) {
            var data = {
                "new_account_maltainvest": "1"
            };
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    data[key] = params[key];
                }
            };
            sendMessage(data);
        },
        statement: function statement(params) {
            var data = {
                statement: 1
            };

            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    data[key] = params[key];
                }
            }

            sendMessage(data);
        },
        ping: function ping() {
            var data = {
                ping: 1
            };
            sendMessage(data);
        },
        setSelfExclusion: function setSelfExclusion(params) {
            var data = {
                set_self_exclusion: 1
            };

            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    data[key] = params[key];
                }
            }

            sendMessage(data);
        },
        getSelfExclusion: function getSelfExclusion() {
            var data = {
                get_self_exclusion: 1
            };

            sendMessage(data);
        },
        TAndCApprovalSend: function TAndCApprovalSend() {
            var data = {
                tnc_approval: 1
            };
            sendMessage(data);
        }
    };

    websocketService.closeConnection = function () {
        if (dataStream) {
            dataStream.close();
        }
    };

    var receiveMessage = function receiveMessage(_response) {
        var message = JSON.parse(_response.data);

        if (message) {
            if (message.error) {
                if (message.error.code === 'InvalidToken') {
                    localStorageService.manageInvalidToken();
                }
            }

            var messageType = message.msg_type;
            switch (messageType) {
                case 'authorize':
                    if (message.authorize) {
                        message.authorize.token = message.echo_req.authorize;
                        window._trackJs.userId = message.authorize.loginid;
                        appStateService.isLoggedin = true;
                        appStateService.virtuality = message.authorize.is_virtual;
                        localStorage.landingCompanyName = message.authorize.landing_company_fullname;
                        appStateService.scopes = message.authorize.scopes;
                        amplitude.setUserId(message.authorize.loginid);

                        if (_.isEmpty(message.authorize.currency)) {
                            websocketService.sendRequestFor.currencies();
                        } else {
                            sessionStorage.currency = message.authorize.currency;
                        }

                        $rootScope.$broadcast('authorize', message.authorize, message['req_id'], message['passthrough']);
                    } else {
                        var errorMessage = "Unexpected Error!";
                        if (message.hasOwnProperty('error')) {
                            localStorageService.removeToken(message.echo_req.authorize);
                            errorMessage = message.error.message;
                        }
                        $rootScope.$broadcast('authorize', false, errorMessage);
                        appStateService.isLoggedin = false;
                    }
                    break;
                case 'website_status':
                    $rootScope.$broadcast('website_status', message.website_status);
                    localStorage.termsConditionsVersion = message.website_status.terms_conditions_version;
                    break;
                case 'active_symbols':
                    var markets = message.active_symbols;
                    var groupedMarkets = _.groupBy(markets, 'market');
                    var openMarkets = {};
                    for (var key in groupedMarkets) {
                        if (groupedMarkets.hasOwnProperty(key)) {
                            if (groupedMarkets[key][0].exchange_is_open == 1) {
                                openMarkets[key] = groupedMarkets[key];
                            }
                        }
                    }
                    //if ( !sessionStorage.hasOwnProperty('active_symbols') || sessionStorage.active_symbols != JSON.stringify(openMarkets) ) {
                    sessionStorage.active_symbols = JSON.stringify(openMarkets);
                    $rootScope.$broadcast('symbols:updated', openMarkets);
                    //}
                    break;
                case 'asset_index':
                    //if ( !sessionStorage.hasOwnProperty('asset_index') || sessionStorage.asset_index != JSON.stringify(message.asset_index) ) {
                    sessionStorage.asset_index = JSON.stringify(message.asset_index);
                    $rootScope.$broadcast('assetIndex:updated');
                    //}
                    break;
                case 'payout_currencies':
                    $rootScope.$broadcast('currencies', message.payout_currencies);
                    break;
                case 'proposal':
                    if (message.proposal) {
                        $rootScope.$broadcast('proposal', message.proposal, message.req_id);
                    } else if (message.error) {
                        $rootScope.$broadcast('proposal:error', message.error, message.req_id);
                    }
                    break;
                case 'contracts_for':
                    var symbol = message.echo_req.contracts_for;
                    var groupedSymbol = _.groupBy(message.contracts_for.available, 'contract_category');
                    $rootScope.$broadcast('symbol', groupedSymbol);
                    break;
                case 'buy':
                    if (message.error) {
                        $rootScope.$broadcast('purchase:error', message.error);
                        alertService.displayError(message.error.message);
                    } else {
                        $rootScope.$broadcast('purchase', message);
                    }
                    break;
                case 'balance':
                    if (!message.error) {
                        $rootScope.$broadcast('balance', message.balance);
                    }
                    break;
                case 'tick':
                    $rootScope.$broadcast('tick', message);
                    break;
                case 'history':
                    $rootScope.$broadcast('history', message);
                    break;
                case 'candles':
                    $rootScope.$broadcast('candles', message);
                    break;
                case 'ohlc':
                    $rootScope.$broadcast('ohlc', message);
                    break;
                case 'portfolio':
                    $rootScope.$broadcast('portfolio', message.portfolio);
                    break;
                case 'profit_table':
                    if (message.profit_table) {
                        $rootScope.$broadcast('profit_table:update', message.profit_table, message.req_id);
                    } else if (message.error) {
                        $rootScope.$broadcast('profit_table:error', message.error.message);
                    }
                    break;
                case 'sell_expired':
                    $rootScope.$broadcast('sell:expired', message.sell_expired);
                    break;
                case 'proposal_open_contract':
                    $rootScope.$broadcast('proposal:open-contract', message.proposal_open_contract, message.req_id);
                    break;
                case 'landing_company_details':
                    $rootScope.$broadcast('landing_company_details', message.landing_company_details);
                    break;
                case 'reality_check':
                    $rootScope.$broadcast('reality_check', message.reality_check);
                    break;
                case 'verify_email':
                    if (message.verify_email) {
                        $rootScope.$broadcast('verify_email', message.verify_email);
                    } else if (message.error) {
                        $rootScope.$broadcast('verify_email:error', message.error.details);
                    }
                    break;
                case 'residence_list':
                    $rootScope.$broadcast('residence_list', message.residence_list);
                    break;
                case 'new_account_virtual':
                    if (message.new_account_virtual) {
                        $rootScope.$broadcast('new_account_virtual', message.new_account_virtual);
                    } else if (message.error) {
                        $rootScope.$broadcast('new_account_virtual:error', message.error);
                    }
                    break;
                case 'get_settings':
                    if (message.get_settings) {
                        $rootScope.$broadcast('get_settings', message.get_settings);
                    } else if (message.error) {
                        $rootScope.$broadcast('get_settings:error', message.error.message);
                    }
                    break;
                case 'landing_company':
                    $rootScope.$broadcast('landing_company', message.landing_company);
                    break;
                case 'states_list':
                    $rootScope.$broadcast('states_list', message.states_list);
                    break;
                case 'new_account_real':
                    if (message.new_account_real) {
                        $rootScope.$broadcast('new_account_real', message.new_account_real);
                    } else if (message.error) {
                        $rootScope.$broadcast('new_account_real:error', message.error);
                    }
                    break;
                case 'new_account_maltainvest':
                    if (message.new_account_maltainvest) {
                        $rootScope.$broadcast('new_account_maltainvest', message.new_account_maltainvest);
                    } else if (message.error) {
                        $rootScope.$broadcast('new_account_maltainvest:error', message.error);
                    }
                    break;
                case 'statement':
                    if (message.statement) {
                        $rootScope.$broadcast('statement:update', message.statement, message.req_id);
                    } else if (message.error) {
                        $rootScope.$broadcast('statement:error', message.error.message);
                    }
                    break;
                case 'get_self_exclusion':
                    if (message.get_self_exclusion) {
                        $rootScope.$broadcast('get-self-exclusion', message.get_self_exclusion);
                    } else if (message.error) {
                        $rootScope.$broadcast('get-self-exclusion:error', message.error.message);
                    }
                    break;
                case 'set_self_exclusion':
                    if (message.set_self_exclusion) {
                        $rootScope.$broadcast('set-self-exclusion', message.set_self_exclusion);
                    } else if (message.error) {
                        $rootScope.$broadcast('set-self-exclusion:error', message.error.message);
                    }
                    break;
                case 'set_settings':
                    if (message.set_settings) {
                        $rootScope.$broadcast('set-settings', message.set_settings);
                    } else if (message.error) {
                        $rootScope.$broadcast('set-settings:error', message.error.message);
                    }
                    break;
                case 'tnc_approval':
                    if (message.tnc_approval) {
                        $rootScope.$broadcast('tnc_approval', message.tnc_approval);
                    } else if (message.error) {
                        $rootScope.$broadcast('tnc_approval:error', message.error);
                    }
                default:
            }
        }
    };

    return websocketService;
}]);
'use strict';

/**
 * @name accounts controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.accounts.controllers').controller('AccountsController', Accounts);

    Accounts.$inject = ['$scope', '$state', '$ionicSideMenuDelegate', 'accountService', 'appStateService', 'utilsService', 'websocketService'];

    function Accounts($scope, $state, $ionicSideMenuDelegate, accountService, appStateService, utilsService, websocketService) {
        var vm = this;

        var init = function init() {
            vm.accounts = accountService.getAll();
            vm.selectedAccount = accountService.getDefault().token;
        };

        var updateSymbols = function updateSymbols() {
            // Wait untile the login progress is finished
            if (!appStateService.isLoggedin) {
                setTimeout(updateSymbols, 500);
            } else {
                websocketService.sendRequestFor.symbols();
                websocketService.sendRequestFor.assetIndex();
            }
        };

        init();

        vm.updateAccount = function (_selectedAccount) {
            accountService.setDefault(_selectedAccount);
            accountService.validate();
            updateSymbols();
            appStateService.isChangedAccount = true;
            appStateService.isCheckedAccountType = false;
            sessionStorage.removeItem('start');
            sessionStorage.removeItem('_interval');
            appStateService.isProfitTableSet = false;
            appStateService.isStatementSet = false;
            appStateService.profitTableRefresh = true;
            appStateService.statementRefresh = true;
            appStateService.isNewAccountReal = false;
            appStateService.isNewAccountMaltainvest = false;
            appStateService.hasMLT = false;
            sessionStorage.removeItem('countryParams');
            appStateService.isPopupOpen = false;
            $ionicSideMenuDelegate.toggleLeft();
        };

        $scope.$on('authorize', function (e, authorize) {
            if (authorize && appStateService.newAccountAdded) {
                accountService.add(authorize);
                accountService.setDefault(accountService.addedAccount);
                appStateService.newAccountAdded = false;
                vm.accounts = accountService.getAll();
                vm.selectedAccount = accountService.getDefault().token;
                vm.updateAccount(vm.selectedAccount);
                $state.go('trade');
                accountService.addedAccount = '';
            }
        });
    }
})();
'use strict';

/**
 * @name accounts directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.accounts.directives').directive('bgAccounts', Accounts);

  function Accounts() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/share/components/accounts/accounts.template.html',
      controller: 'AccountsController',
      controllerAs: 'vm',
      bindToContoller: true,
      scope: {}
    };

    return directive;
  }
})();
'use strict';

/**
 * @name app version controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
		'use strict';

		angular.module('binary.share.components.app-version.controllers').controller('AppVersionController', AppVersion);

		AppVersion.$inject = ['$scope', '$ionicPlatform', 'appVersionService'];

		function AppVersion($scope, $ionicPlatform, appVersionService) {
				var vm = this;
				$ionicPlatform.ready(function () {
						$scope.$applyAsync(function () {
								if (window.cordova) {
										cordova.getAppVersion(function (version) {
												vm.appVersion = version;
										}, function (err) {
												console.log(err);
										});
								} else {
										appVersionService.getAppVersion().success(function (data) {
												vm.appVersion = data.version;
										}).error(function (data) {
												vm.appVersion = "0.0.0";
										});
								}
						});
				});
		}
})();
'use strict';

/**
 * @name app version directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.app-version.directives').directive('bgAppVersion', AppVersion);

    function AppVersion() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/share/components/app-version/app-version.template.html',
            controller: 'AppVersionController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name balance controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.balance.controllers').controller('BalanceController', Balance);

  Balance.$inject = ['$scope', 'websocketService'];

  function Balance($scope, websocketService) {
    var vm = this;
    vm.balance = null;

    $scope.$on('authorize', function (e, response, requestId, pathtrough) {
      $scope.$applyAsync(function () {
        vm.balance = {
          currency: response.currency,
          balance: response.balance,
          loginid: response.loginid
        };
        changeProposalCurrency();
      });
    });

    $scope.$on('balance', function (e, response) {
      $scope.$applyAsync(function () {
        vm.balance = response;
        changeProposalCurrency();
      });
    });

    $scope.$on('language:updated', function (e) {
      websocketService.sendRequestFor.forgetAll('balance');
      vm.balance = null;
      getBalance();
    });

    function getBalance() {
      websocketService.sendRequestFor.balance();
    }

    function changeProposalCurrency() {
      $scope.$broadcast('currency:changed', vm.balance.currency);
    }

    getBalance();
  }
})();
'use strict';

/**
 * @name balance directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.balance.directives').directive('bgBalance', Balance);

  Balance.$inject = ['websocketService'];

  function Balance(websocketService) {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/share/components/balance/balance.template.html',
      controller: 'BalanceController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {
        proposal: '=?'
      },
      link: link
    };

    function link(scope, element, attributes, vm) {
      scope.$on('$destroy', function () {
        websocketService.sendRequestFor.forgetStream(vm.balance.id);
      });
    }

    return directive;
  }
})();
'use strict';

/**
 * @name Connection Lost Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.connectivity.controllers').controller('ConnectionLostController', ConnectionLost);

  ConnectionLost.$inject = ['$scope'];

  function ConnectionLost($scope) {
    var vm = this;

    vm.showMessage = false;

    $scope.$on('connection:ready', function (e) {
      $scope.$applyAsync(function () {
        vm.showMessage = false;
      });
    });

    $scope.$on('connection:error', function (e) {
      $scope.$applyAsync(function () {
        vm.showMessage = true;
      });
    });
  }
})();
'use strict';

/**
 * @name Connection Lost directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/19/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.connectivity.directives').directive('bgConnectionLost', ConnectionLost);

  function ConnectionLost() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/share/components/connectivity/connection-lost.template.html',
      controller: 'ConnectionLostController',
      controllerAs: 'vm',
      scope: {}
    };

    return directive;
  }
});
'use strict';

/**
 * @name Connectivity Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/22/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.connectivity.controllers').controller('ConnectivityController', Connectivity);

  Connectivity.$inject = ['$scope', '$state', '$cordovaNetwork'];

  function Connectivity($scope, $state, $cordovaNetwork) {
    var vm = this;

    vm.isOffline = function () {
      if (ionic.Platform.isWebView()) {
        return !$cordovaNetwork.isOnline();
      } else {
        !navigator.onLine;
      }
    };

    vm.isOnline = function () {
      if (ionic.Platform.isWebView()) {
        return $cordovaNetwork.isOnline();
      } else {
        return navigator.onLine;
      }
    };

    function startWatchingNetwork() {
      if (ionic.Platform.isWebView()) {
        $scope.$on('$cordovaNetwork:online', function (e, networkState) {
          $state.go('home');
        });

        $scope.$on('$cordovaNetwork:offline', function (e, netwrorkState) {
          $state.go('no-connection');
        });
      } else {
        window.addEventListener('online', function (e) {
          $state.go('home');
        }, false);

        window.addEventListener('offline', function (e) {
          $state.go('no-connection');
        }, false);
      }
    }

    function init() {
      startWatchingNetwork();
    }

    $scope.$on('$stateChangeSuccess', function (e, current) {
      if (!vm.isOnline()) {
        $state.go('no-connection');
      }
    });

    init();
  }
})();
'use strict';

/**
 * @name Connectivity Directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/22/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.connectivity.directives').directive('bgConnectivity', Connectivity);

  function Connectivity() {
    var directive = {
      restrict: 'E',
      controller: 'ConnectivityController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {}
    };

    return directive;
  }
})();
'use strict';

/**
 * @name header controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/08/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    'use strict';

    angular.module('binary.share.components').controller('HeaderController', Header);

    Header.$inject = ['$scope', '$state', '$ionicHistory', '$ionicSideMenuDelegate', 'appStateService'];

    function Header($scope, $state, $ionicHistory, $ionicSideMenuDelegate, appStateService) {
        var vm = this;
        vm.hideMenuButton = false;
        vm.disableMenuButton = false;
        vm.showBack = false;
        $ionicSideMenuDelegate.canDragContent(false);
        $ionicHistory.backView(null);
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();

        vm.toggleSideMenu = function () {
            if (appStateService.tradeMode || !appStateService.purchaseMode) {
                $ionicSideMenuDelegate.toggleLeft();
            }
        };

        $scope.$watch(function () {
            return appStateService.purchaseMode;
        }, function () {
            vm.disableMenuButton = appStateService.purchaseMode;
        });

        $scope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
            vm.to = to;
            vm.from = from;
            if (['transactiondetail', 'language', 'profile', 'self-exclusion'].indexOf(vm.to.name) > -1) {
                vm.hideMenuButton = true;
                vm.showBack = true;
            } else if (['acceptTermsAndConditions'].indexOf(vm.to.name) > -1) {
                vm.hideMenuButton = true;
                vm.showBack = false;
            } else {
                vm.hideMenuButton = false;
                vm.showBack = false;
                if (vm.from.name == 'profittable') {
                    appStateService.isProfitTableSet = false;
                }
                if (vm.from.name == 'statement') {
                    appStateService.isStatementSet = false;
                }
            }
        });

        // back button function
        vm.goToPrevPage = function () {
            $state.go(vm.from);
        };
    }
})();
'use strict';

/**
 * @name header directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/07/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.share.components').directive('bgHeader', Header);

  function Header() {
    var directive = {
      link: link,
      templateUrl: 'js/share/components/header/header.template.html',
      retrict: 'A',
      controller: 'HeaderController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {
        spinLogo: '='
      }
    };

    function link() {}

    return directive;
  }
})();
'use strict';

/**
 * @name language-list directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 10/13/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.share.components.language.directives').directive('bgLanguageList', LanguageList);

  function LanguageList() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/share/components/language/language-list.template.html',
      controller: 'LanguageController',
      controllerAs: 'vm',
      scope: {}
    };

    return directive;
  }
})();
'use strict';

/**
 * @name language directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
    'use strict';

    angular.module('binary.share.components.language.controllers').controller('LanguageController', Language);

    Language.$inject = ['$scope', 'config', 'languageService', 'websocketService', 'appStateService'];

    function Language($scope, config, languageService, websocketService, appStateService) {

        var vm = this;
        vm.languages = [];
        vm.appSupportedLanguages = [];
        vm.languagesList = [];
        vm.isLanguageReady = false;
        vm.ios = ionic.Platform.isIOS();
        vm.android = ionic.Platform.isAndroid();
        websocketService.sendRequestFor.websiteStatus();
        $scope.$on('website_status', function (e, website_status) {
            if (!vm.isLanguageReady) {
                vm.languages = [];
                vm.languagesList = website_status.supported_languages;
                vm.appSupportedLanguages = config.appSupportedLanguages;
                _.forEach(vm.appSupportedLanguages, function (value) {
                    vm.value = value.toUpperCase();
                    if (vm.languagesList.indexOf(vm.value) > -1) {
                        var LanguageCode = vm.value.toLowerCase();
                        var languageNativeName = languageService.getLanguageNativeName(LanguageCode);
                        vm.languages.push({
                            'id': LanguageCode,
                            'title': languageNativeName
                        });
                    }
                });
                vm.isLanguageReady = true;
                appStateService.isLanguageReady = true;
                $scope.$apply();
            }
        });

        vm.language = languageService.read();

        vm.changeLanguage = function (language) {
            vm.language = language || vm.language;
            languageService.update(vm.language);
        };
    }
})();
'use strict';

/**
 * @name language directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.share.components.language.directives').directive('language', Language);

  function Language() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/share/components/language/language.template.html',
      controller: 'LanguageController',
      controllerAs: 'vm',
      scope: {},
      bindToController: true
    };

    return directive;
  }
})();
'use strict';

/**
 * @name logout controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/15/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.logout.controllers').controller('LogoutController', Logout);

  Logout.$inject = ['$rootScope', '$state', 'accountService', 'appStateService', 'websocketService', 'alertService', 'proposalService'];

  function Logout($rootScope, $state, accountService, appStateService, websocketService, alertService, proposalService) {
    var vm = this;
    vm.logout = function (res) {
      alertService.confirmRemoveAllAccount(function (res) {
        if (typeof res !== "boolean") {
          if (res == 1) res = true;else res = false;
        }

        if (res) {
          websocketService.logout();
        }
      });
    };
  }
})();
'use strict';

/**
 * @name logout directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.logout.directives').directive('bgLogout', Logout);

    function Logout() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/share/components/logout/logout.template.html',
            controller: 'LogoutController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

(function () {
  'use strict';

  angular.module('binary.share.components.long-press.directives').directive('onLongPress', LongPress);

  LongPress.$inject = ['$timeout', '$interval'];

  function LongPress($timeout, $interval) {
    var directive = {
      restrict: 'A',
      link: link
    };

    function link(scope, elm, attrs) {
      var timer = 0;
      var interval = attrs.interval ? Number(attrs.interval) : 300;
      scope.longPress = false;

      var startPress = function startPress(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        // Locally scoped variable that will keep track of the long press
        scope.longPress = true;

        if (attrs.repetitive && attrs.repetitive === "true") {
          // run the function befor repeating in the interval
          scope.$eval(attrs.onLongPress);

          timer = $interval(function () {
            if (scope.longPress) {
              // If the touchend event hasn't fired,
              // apply the function given in on the element's on-long-press attribute
              scope.$eval(attrs.onLongPress);
            }
          }, interval);
        } else {
          // We'll set a timeout for 600 ms for a long press
          timer = $timeout(function () {
            if (scope.longPress) {
              // If the touchend event hasn't fired,
              // apply the function given in on the element's on-long-press attribute
              scope.$eval(attrs.onLongPress);
            }
          }, interval);
        }
      };

      var endPress = function endPress(evt) {
        // Prevent the onLongPress event from firing
        scope.longPress = false;

        if (attrs.repetitive && attrs.repetitive === "true") {
          $interval.cancel(timer);
        } else {
          $timeout.cancel(timer);
        }

        timer = undefined;

        // If there is an on-touch-end function attached to this element, apply it
        if (attrs.onTouchEnd) {
          scope.$apply(function () {
            scope.$eval(attrs.onTouchEnd);
          });
        }
      };

      elm.bind('touchstart', startPress);
      elm.bind('touchend', endPress);
      elm.bind('mousedown', startPress);
      elm.bind('mouseup', endPress);
    }

    return directive;
  }
})();
'use strict';

/**
 * @name number directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/02/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.number.directives').directive('bgNumber', BgNumber);

  function BgNumber() {
    var directive = {
      restrict: 'A',
      require: '?ngModel',
      link: link
    };

    function link(scope, element, attrs, ngModel) {

      if (ngModel) {
        ngModel.$formatters.push(function (modelValue) {
          if (!modelValue) {
            return modelValue;
          }
          return Number(modelValue);
        });

        ngModel.$parsers.push(function (viewValue) {
          if (!viewValue) {
            return viewValue;
          }
          return Number(viewValue);
        });
      }
    }

    return directive;
  }
})();
'use strict';

/**
 * @name ping controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.share.components.ping.controllers').controller('PingController', Ping);

  Ping.$inject = ['$timeout', 'appStateService', 'websocketService'];

  function Ping($timeout, appStateService, websocketService) {

    function init() {
      ping();
    }

    function ping() {
      if (appStateService.isLoggedin) {
        websocketService.sendRequestFor.ping();
      }

      $timeout(ping, 60000);
    }

    init();
  }
})();
'use strict';

/**
 * @name ping directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 * Application Header
 */

(function () {
  'use strict';

  angular.module('binary.share.components.ping.directives').directive('ping', Ping);

  function Ping() {
    var directive = {
      restrict: 'E',
      controller: 'PingController',
      controllerAs: 'vm',
      scope: {}
    };

    return directive;
  }
})();
'use strict';

/**
 * @name real-account-opening controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.real-account-opening.controllers').controller('RealAccountOpeningController', RealAccountOpening);

    RealAccountOpening.$inject = ['$scope', '$state', 'websocketService', 'appStateService', 'accountService'];

    function RealAccountOpening($scope, $state, websocketService, appStateService, accountService) {
        var vm = this;
        vm.data = {};
        vm.countryParams = {};
        vm.showUpgradeLink = false;
        vm.showUpgradeLinkMaltainvest = false;
        vm.isCheckedCompany = false;
        appStateService.hasMLT = false;
        vm.isVirtual = false;
        vm.hasGamingAndVirtual = false;
        vm.hasGamingNotVirtual = false;
        vm.hasFinancialAndMaltainvest = false;
        vm.idsFound = [];

        vm.reset = function () {
            vm.data = {};
            vm.countryParams = {};
            vm.showUpgradeLink = false;
            vm.showUpgradeLinkMaltainvest = false;
            vm.isCheckedCompany = false;
            appStateService.hasMLT = false;
            vm.hasGamingAndVirtual = false;
            vm.hasGamingNotVirtual = false;
            vm.hasFinancialAndMaltainvest = false;
            vm.idsFound = [];
            appStateService.isNewAccountReal = false;
            appStateService.isNewAccountMaltainvest = false;
            appStateService.isCheckedAccountType = false;
            vm.hasGamingAndMaltainvest = false;
            vm.notMaltainvest = false;
            vm.hasGamingAndFinancialAndMaltainvest = false;
        };

        // get account-setting and landing-company
        vm.getCompany = function () {
            appStateService.isCheckedAccountType = true;
            websocketService.sendRequestFor.accountSetting();
        };

        // in case the authorize response is passed before the execution of this controller
        // get the virtuality of account by appStateService.virtuality which is saved in authorize
        if (appStateService.isLoggedin && !appStateService.isCheckedAccountType) {
            vm.reset();
            if (appStateService.virtuality == 1) {
                vm.isVirtual = true;
            } else {
                vm.isVirtual = false;
            }
            vm.getCompany();
        }

        // in case still not authorized when this controller is executed listen for the response of authorize
        $scope.$on('authorize', function (e, response) {
            if (!appStateService.isCheckedAccountType) {
                vm.reset();
                if (response.is_virtual == 1) {
                    vm.isVirtual = true;
                } else {
                    vm.isVirtual = false;
                }

                vm.getCompany();
            }
        });

        $scope.$on('get_settings', function (e, get_settings) {
            vm.data.setting = get_settings;
            vm.data.countryCode = vm.data.setting.country_code;
            vm.data.countryOfAccount = vm.data.setting.country;
            vm.countryParams.countryCode = vm.data.countryCode;
            vm.countryParams.countryOfAccount = vm.data.countryOfAccount;
            sessionStorage.countryParams = JSON.stringify(vm.countryParams);
            if (vm.data.countryCode != "jp") {
                websocketService.sendRequestFor.landingCompanySend(vm.data.countryCode);
            }
        });
        $scope.$on('landing_company', function (e, landing_company) {
            if (!vm.isCheckedCompany) {
                vm.isCheckedCompany = true;
                vm.accountStates(landing_company);
            }
        });

        // check 3 states combining of Maltainvest shortcode, gaming company and financial company
        vm.accountStates = function (landing_company) {
            vm.data.landingCompany = landing_company;
            if (vm.data.landingCompany.hasOwnProperty('gaming_company')) {
                if (vm.isVirtual) {
                    vm.hasGamingAndVirtual = true;
                    vm.getToken();
                } else {
                    if (vm.data.landingCompany.hasOwnProperty('financial_company') && vm.data.landingCompany.financial_company.shortcode == "maltainvest") {
                        vm.hasGamingNotVirtual = true;
                        vm.getToken();
                    }
                }
            } else if (!vm.data.landingCompany.hasOwnProperty('gaming_company')) {
                if (vm.isVirtual) {
                    if (vm.data.landingCompany.hasOwnProperty('financial_company') && vm.data.landingCompany.financial_company.shortcode == "maltainvest") {
                        vm.hasFinancialAndMaltainvest = true;
                        vm.getToken();
                    }
                }
            }
        };

        // get tokens from localStorage
        vm.getToken = function () {
            if (localStorage.hasOwnProperty('accounts')) {
                vm.accounts = JSON.parse(localStorage.accounts);
                vm.findTokens();
            }
        };

        vm.findTokens = function () {
            if (vm.hasGamingAndVirtual == true) {
                vm.idsFound = [];
                vm.count = vm.accounts.length;
                vm.accounts.forEach(function (el, i) {
                    vm.val = vm.accounts[i]['id'];
                    if (vm.val.search('VRTC') > -1) {
                        vm.idsFound.push('VRTC');
                    } else if (vm.val.search('MX') > -1) {
                        vm.idsFound.push('MXorCRorMLT');
                    } else if (vm.val.search('CR') > -1) {
                        vm.idsFound.push('MXorCRorMLT');
                    } else if (vm.val.search('MLT') > -1) {
                        vm.idsFound.push('MXorCRorMLT');
                    }

                    if (! --vm.count) {
                        vm.gamingAndVirtualStages();
                    }
                });
            } else if (vm.hasGamingNotVirtual == true) {
                vm.idsFound = [];
                vm.count = vm.accounts.length;
                vm.accounts.forEach(function (el, i) {
                    vm.val = vm.accounts[i]['id'];
                    if (vm.val.search('MF') > -1) {
                        vm.idsFound.push('MF');
                    }

                    if (! --vm.count) {
                        vm.gamingAndFinancialAndMaltainvestStages();
                    }
                });
            } else if (vm.hasFinancialAndMaltainvest == true) {
                vm.idsFound = [];
                vm.count = vm.accounts.length;
                vm.accounts.forEach(function (el, i) {
                    vm.val = vm.accounts[i]['id'];
                    if (vm.val.search('MF') > -1) {
                        vm.idsFound.push('MF');
                    }

                    if (! --vm.count) {
                        vm.financialAndMaltainvestStages();
                    }
                });
            }
        };

        vm.gamingAndVirtualStages = function () {
            if (vm.idsFound.indexOf('VRTC') > -1 && vm.idsFound.indexOf('MXorCRorMLT') == -1) {
                // can upgrade to MX or CR
                // use https://developers.binary.com/api/#new_account_real
                vm.newAccountReal();
            }
        };

        vm.gamingAndFinancialAndMaltainvestStages = function () {
            if (vm.idsFound.indexOf('MF') == -1) {
                appStateService.hasMLT = true;
                vm.newAccountMaltainvest();
            }
        };
        vm.financialAndMaltainvestStages = function () {
            if (vm.idsFound.indexOf('MF') == -1) {
                vm.newAccountMaltainvest();
            }
        };
        // functions for showing the upgrade link and show the related forms to the condition
        vm.newAccountReal = function () {
            $scope.$applyAsync(function () {
                if (appStateService.isCheckedAccountType) {
                    vm.showUpgradeLink = true;
                    appStateService.isNewAccountReal = true;
                }
            });
        };
        vm.newAccountMaltainvest = function () {
            $scope.$applyAsync(function () {
                if (appStateService.isCheckedAccountType) {
                    vm.showUpgradeLinkMaltainvest = true;
                    appStateService.isNewAccountMaltainvest = true;
                }
            });
        };
        $scope.$on('logout', function (e) {
            $scope.$applyAsync(function () {
                vm.reset();
            });
        });

        // link to forms page
        vm.navigateToUpgrade = function () {
            $state.go('realaccountopening');
        };
    }
})();
'use strict';

/**
 * @name real-account-opening directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.real-account-opening.directives').directive('bgRealAccountOpening', RealAccountOpening);

    function RealAccountOpening() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/share/components/real-account-opening/real-account-opening.template.html',
            controller: 'RealAccountOpeningController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name reality-check controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.reality-check.controllers').controller('RealityCheckController', RealityCheck);

  RealityCheck.$inject = ['$scope', '$timeout', '$translate', '$location', '$state', '$ionicPopup', 'websocketService', 'appStateService', 'accountService', 'alertService', 'languageService', 'proposalService'];

  function RealityCheck($scope, $timeout, $translate, $location, $state, $ionicPopup, websocketService, appStateService, accountService, alertService, languageService, proposalService) {
    var vm = this;
    var landingCompanyName;
    $scope.$on('authorize', function (e, authorize) {
      vm.sessionLoginId = authorize.loginid;
      // check if user is not already authorized, account is real money account  & is not changed in app
      if (!appStateService.isRealityChecked && authorize.is_virtual == 0 && !appStateService.isChangedAccount) {
        if (!_.isEmpty(sessionStorage.realityCheckStart)) {
          sessionStorage.removeItem('realityCheckStart');
        }
        if (!_.isEmpty(sessionStorage.start)) {
          sessionStorage.removeItem('start');
        }
        landingCompanyName = authorize.landing_company_name;
        websocketService.sendRequestFor.landingCompanyDetails(landingCompanyName);
      }
      // check if user is already authorized, account changed and is virtual money account
      else if (appStateService.isRealityChecked && appStateService.isChangedAccount && authorize.is_virtual == 1) {
          $timeout.cancel(vm.realityCheckTimeout);
          appStateService.isChangedAccount = false;
          appStateService.isRealityChecked = true;
          if (!_.isEmpty(sessionStorage.realityCheckStart)) {
            sessionStorage.removeItem('realityCheckStart');
          }
          if (!_.isEmpty(sessionStorage.start)) {
            sessionStorage.removeItem('start');
          }
        }
        // check if account is changed and is real money account
        else if (appStateService.isRealityChecked && appStateService.isChangedAccount && authorize.is_virtual == 0) {
            if (vm.realityCheckTimeout) {
              $timeout.cancel(vm.realityCheckTimeout);
            }
            if (!_.isEmpty(sessionStorage.realityCheckStart)) {
              sessionStorage.removeItem('realityCheckStart');
            }
            if (!_.isEmpty(sessionStorage.start)) {
              sessionStorage.removeItem('start');
            }
            appStateService.isRealityChecked = false;
            landingCompanyName = authorize.landing_company_name;
            websocketService.sendRequestFor.landingCompanyDetails(landingCompanyName);
            appStateService.isChangedAccount = false;
          } else if (!appStateService.isRealityChecked && appStateService.isChangedAccount && authorize.is_virtual == 0) {
            if (vm.realityCheckTimeout) {
              $timeout.cancel(vm.realityCheckTimeout);
            }
            if (!_.isEmpty(sessionStorage.realityCheckStart)) {
              sessionStorage.removeItem('realityCheckStart');
            }
            if (!_.isEmpty(sessionStorage.start)) {
              sessionStorage.removeItem('start');
            }
            appStateService.isRealityChecked = false;
            landingCompanyName = authorize.landing_company_name;
            websocketService.sendRequestFor.landingCompanyDetails(landingCompanyName);
            appStateService.isChangedAccount = false;
          }
    });

    $scope.$on('landing_company_details', function (e, landingCompanyDetails) {
      if (landingCompanyDetails.has_reality_check === 1) {
        vm.hasRealityCheck();
      }
    });

    vm.setInterval = function setInterval(val) {
      var set = sessionStorage.setItem('_interval', val);
    };
    vm.setStart = function setInterval(val) {
      var set = sessionStorage.setItem('start', val);
    };

    vm.getInterval = function (key) {
      return sessionStorage.getItem(key);
    };
    vm.getStart = function (key) {
      return sessionStorage.getItem(key);
    };

    vm.removeInterval = function (key) {
      var remove = sessionStorage.removeItem(key);
    };
    vm.removeStart = function (key) {
      var remove = sessionStorage.removeItem(key);
    };

    vm.hasRealityCheck = function () {
      // if not asked the interval from user and the start time of reality check popups are not set in sessionStorage
      if (!appStateService.isRealityChecked && _.isEmpty(sessionStorage._interval) == true) {
        vm.realityCheck();
      }
      // if not asked the interval from user and the start time of reality check popups are set in sessionStorage
      // happens when user refresh the browser
      else if (!appStateService.isRealityChecked && !_.isEmpty(sessionStorage.start)) {
          appStateService.isRealityChecked = true;
          // calculate the difference between time of last popup and current time
          var timeGap = vm.getStart('start');
          var thisTime = new Date().getTime();
          // if the difference above is smaller than the interval set the period for popup timeout to remained time
          if (vm.getInterval('_interval') * 60000 - (thisTime - timeGap) > 0) {
            var period = vm.getInterval('_interval') * 60000 - (thisTime - timeGap);
            vm.realityCheckTimeout = $timeout(vm.getRealityCheck, period);
          }
        }
        // if user did not refresh the app and the interval is set
        else {
            if (_.isEmpty(sessionStorage._interval) == false) {
              var period = vm.getInterval('_interval') * 60000;
              vm.realityCheckTimeout = $timeout(vm.getRealityCheck, period);
            }
          }
    };

    vm.realityCheck = function () {
      appStateService.isRealityChecked = true;
      vm.data = {};
      vm.data.interval = 60;
      if (!appStateService.isPopupOpen) {
        appStateService.isPopupOpen = true;
        $translate(['realitycheck.continue', 'realitycheck.title']).then(function (translation) {
          alertService.displayRealitCheckInterval(translation['realitycheck.title'], 'realitycheck getinterval', $scope, 'js/share/components/reality-check/interval-popup.template.html', [{
            text: translation['realitycheck.continue'],
            type: 'button-positive',
            onTap: function onTap(e) {
              if (vm.data.interval <= 120 && vm.data.interval >= 10) {
                vm.setInterval(vm.data.interval);
                vm.data.start_interval = new Date().getTime();
                vm.setStart(vm.data.start_interval);
                vm.hasRealityCheck();
                appStateService.isPopupOpen = false;
                sessionStorage.setItem('realityCheckStart', Date.now());
              } else {
                e.preventDefault();
              }
            }
          }]);
        });
      }
    };

    vm.getLastInterval = function () {
      vm.removeInterval('_interval');
      vm.setInterval(vm.data.interval);
    };

    $scope.$on('reality_check', function (e, reality_check) {
      vm.alertRealityCheck(reality_check);
    });

    vm.getRealityCheck = function () {
      websocketService.sendRequestFor.realityCheck();
    };
    vm.sessionTime = function (reality_check) {
      vm.realityCheckitems.start_time = sessionStorage.getItem('realityCheckStart');
      vm.now = Date.now();
      vm.duration = vm.now - vm.realityCheckitems.start_time;
      vm.realityCheckitems.days = Math.floor(vm.duration / 864e5);
      vm.hour = vm.duration - vm.realityCheckitems.days * 864e5;
      vm.realityCheckitems.hours = Math.floor(vm.hour / 36e5);
      vm.min = vm.duration - (vm.realityCheckitems.days * 864e5 + vm.realityCheckitems.hours * 36e5);
      vm.realityCheckitems.minutes = Math.floor(vm.min / 60000);
    };

    vm.logout = function () {
      alertService.confirmRemoveAllAccount(function (res) {
        if (typeof res !== "boolean") {
          if (res == 1) res = true;else res = false;
        }

        if (res) {
          websocketService.logout();
        }
        if (!res) {
          vm.hasRealityCheck();
        }
      });
    };

    vm.alertRealityCheck = function (reality_check) {
      vm.removeStart('start');
      vm.realityCheckitems = reality_check;
      if (vm.sessionLoginId == vm.realityCheckitems.loginid && !appStateService.isPopupOpen) {
        vm.sessionTime(reality_check);
        vm.data = {};
        vm.data.interval = parseInt(vm.getInterval('_interval'));
        $timeout.cancel(vm.realityCheckTimeout);
        appStateService.isPopupOpen = true;
        $translate(['realitycheck.title', 'realitycheck.continue', 'realitycheck.logout']).then(function (translation) {
          alertService.displayRealityCheckResult(translation['realitycheck.title'], 'realitycheck result-popup', $scope, 'js/share/components/reality-check/reality-check-result.template.html', [{
            text: translation['realitycheck.logout'],
            type: 'button-secondary',
            onTap: function onTap() {
              vm.logout();
            }
          }, {
            text: translation['realitycheck.continue'],
            type: 'button-positive',
            onTap: function onTap(e) {
              if (vm.data.interval <= 120 && vm.data.interval >= 10) {
                if (vm.sessionLoginId == vm.realityCheckitems.loginid) {
                  vm.getLastInterval(vm.data.interval);
                  vm.data.start_interval = new Date().getTime();
                  vm.setStart(vm.data.start_interval);
                  vm.hasRealityCheck();
                  appStateService.isPopupOpen = false;
                }
              } else {
                e.preventDefault();
              }
            }
          }]);
        });
      }
    };
  };
})();
'use strict';

/**
 * @name reality-check directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.share.components.reality-check.directives').directive('bgRealityCheck', RealityCheck);

    function RealityCheck() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/share/components/reality-check/reality-check.template.html',
            controller: 'RealityCheckController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name bgRegexValidate directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 11/02/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.regex-validate.directives').directive('bgRegexValidate', Validate);

  function Validate() {
    var directive = {
      restrict: 'A',
      link: link,
      require: 'ngModel',
      scope: {
        regex: '@bgRegexValidate'
      }
    };

    return directive;

    function link(scope, elements, attrs, ngModel) {

      scope.$watch(function () {
        return ngModel.$viewValue;
      }, function (newVal, oldVal) {
        if (_.isEmpty(scope.regex) || _.isEmpty(ngModel.$viewValue)) {
          return;
        }

        var regex = RegExp(scope.regex);

        if (!regex.test(ngModel.$viewValue)) {
          ngModel.$setViewValue(oldVal);
          ngModel.$render();
        } else {
          ngModel.$setViewValue(regex.exec(ngModel.$viewValue)[0]);
          ngModel.$render();
        }

        return;
      });
    }
  }
})();
'use strict';

/**
 * @name side-menu directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/08/2016
 * @copyright Binary Ltd
 * Application Side Menu
 */

(function () {
  'use strict';

  angular.module('binary.share.components').directive('bgSideMenu', SideMenu);

  function SideMenu() {
    var directive = {
      link: link,
      templateUrl: 'js/share/components/side-menu/side-menu.template.html',
      retrict: 'A',
      scope: {}
    };

    function link() {}

    return directive;
  }
})();
'use strict';

/**
 * @name spinner-logo controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.spinner-logo.controllers').controller('SpinnerLogoController', SpinnerLogo);

  SpinnerLogo.$inject = ['$scope'];

  function SpinnerLogo($scope) {
    var vm = this;
    vm.start = false;

    $scope.$on('spinner-logo:start', function () {
      vm.start = true;
    });

    $scope.$on('spinner-logo:stop', function () {
      vm.start = false;
    });
  }
})();
'use strict';

/**
 * @name spinner-logo direcvtive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/17/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.spinner-logo.directives').directive('bgSpinnerLogo', SpinnerLogo);

  function SpinnerLogo() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/share/components/spinner-logo/spinner-logo.template.html',
      replace: true,
      controller: 'SpinnerLogoController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {}
    };

    return directive;
  }
})();
'use strict';

/**
 * @name updater module
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/20/2015
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.updater.controllers').controller('UpdaterController', Updater);

  Updater.$inject = ['$ionicPlatform'];

  function Updater($ionicPlatform) {

    $ionicPlatform.ready(function () {
      if (window.codePush) {
        window.codePush.sync();
      }
    });
  }
})();
'use strict';

/**
 * @name updater directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 12/26/2015
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.share.components.updater.directives').directive('bgUpdater', Updater);

  function Updater() {
    var directive = {
      restrict: 'E',
      controller: 'UpdaterController',
      controllerAs: 'vm',
      scope: {}
    };

    return directive;
  }
})();
'use strict';

/**
 * @name new-account-maltainvest controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.new-real-account-opening.components.new-account-maltainvest').controller('NewAccountMaltainvestController', NewAccountMaltainvest);

    NewAccountMaltainvest.$inject = ['$scope', '$state', '$rootScope', 'websocketService', 'appStateService', 'accountService', 'alertService'];

    function NewAccountMaltainvest($scope, $state, $rootScope, websocketService, appStateService, accountService, alertService) {
        var vm = this;
        vm.data = {};
        vm.salutationError = false;
        vm.firstNameError = false;
        vm.lastNameError = false;
        vm.dateOfBirthError = false;
        vm.countryError = false;
        vm.addressLine1Error = false;
        vm.addressLine2Error = false;
        vm.addressCityError = false;
        vm.addressStateError = false;
        vm.addressPostcodeError = false;
        vm.phoneError = false;
        vm.secretQuestionError = false;
        vm.secretAnswerError = false;
        vm.isReadonly = false;
        vm.data.salutation = "Mr";
        vm.data.forexTradingExperience = "0-1 year";
        vm.data.forexTradingFrequency = "0-5 transactions in the past 12 months";
        vm.data.indicesTradingExperience = "0-1 year";
        vm.data.indicesTradingFrequency = "0-5 transactions in the past 12 months";
        vm.data.commoditiesTradingExperience = "0-1 year";
        vm.data.commoditiesTradingFrequency = "0-5 transactions in the past 12 months";
        vm.data.stocksTradingExperience = "0-1 year";
        vm.data.stocksTradingFrequency = "0-5 transactions in the past 12 months";
        vm.data.otherDerivativesTradingExperience = "0-1 year";
        vm.data.otherDerivativesTradingFrequency = "0-5 transactions in the past 12 months";
        vm.data.otherInstrumentsTradingExperience = "0-1 year";
        vm.data.otherInstrumentsTradingFrequency = "0-5 transactions in the past 12 months";
        vm.data.employmentIndustry = "Construction";
        vm.data.educationLevel = "Primary";
        vm.data.incomeSource = "Salaried Employee";
        vm.data.netIncome = "Less than $25,000";
        vm.data.estimatedWorth = "Less than $100,000";
        vm.data.secretQuestion = "Mother's maiden name";

        websocketService.sendRequestFor.residenceListSend();
        $scope.$on('residence_list', function (e, residence_list) {
            vm.residenceList = residence_list;
        });

        $scope.$applyAsync(function () {
            if (appStateService.hasMLT) {
                vm.isReadonly = true;
            }
        });

        vm.validateName = function (val) {
            var regex = /[`~!@#$%^&*)(_=+\[}{\]\\\/";:\?><,|\d]+/;
            return {
                test: function test(val) {
                    if (!vm.isReadonly) {
                        var reg = regex.test(val);

                        if (reg == true) {
                            return false;
                        } else {
                            return true;
                        }
                    } else {
                        return true;
                    }
                }
            };
        }();

        vm.countryParams = JSON.parse(sessionStorage.countryParams);
        vm.data.countryCode = vm.countryParams.countryCode;
        $scope.$applyAsync(function () {
            vm.data.country = vm.countryParams.countryOfAccount;
        });
        vm.findPhoneCode = function (country) {
            return country.value == vm.data.countryCode;
        };

        websocketService.sendRequestFor.statesListSend(vm.data.countryCode);
        $scope.$on('states_list', function (e, states_list) {
            vm.data.statesList = states_list;
            vm.data.state = vm.data.statesList[0].value;
        });
        websocketService.sendRequestFor.accountSetting();
        $scope.$on('get_settings', function (e, get_settings) {
            $scope.$applyAsync(function () {
                if (appStateService.hasMLT) {
                    var birth = new Date(get_settings.date_of_birth);
                    vm.data.dateOfBirth = birth.toISOString().slice(0, 10);
                    vm.data.firstName = get_settings.first_name;
                    vm.data.lastName = get_settings.last_name;
                    vm.data.salutation = get_settings.salutation;
                }
                if (get_settings.hasOwnProperty('address_line_1')) {
                    vm.data.addressLine1 = get_settings.address_line_1;
                }
                if (get_settings.hasOwnProperty('address_line_2')) {
                    vm.data.addressLine2 = get_settings.address_line_2;
                }
                if (get_settings.hasOwnProperty('address_postcode')) {
                    vm.data.addressPostCode = get_settings.address_postcode;
                }
                if (get_settings.hasOwnProperty('address_state')) {
                    vm.data.state = get_settings.address_state;
                }
                if (get_settings.hasOwnProperty('phone')) {
                    vm.data.phone = get_settings.phone;
                }
                if (!get_settings.hasOwnProperty('phone')) {
                    vm.phoneCodeObj = vm.residenceList.find(vm.findPhoneCode);
                    vm.data.phone = '+' + vm.phoneCodeObj.phone_idd;
                }
                if (get_settings.hasOwnProperty('address_city')) {
                    vm.data.addressCity = get_settings.address_city;
                }
            });
        });

        vm.submitAccountOpening = function () {
            vm.salutationError = false;
            vm.firstNameError = false;
            vm.lastNameError = false;
            vm.dateOfBirthError = false;
            vm.countryError = false;
            vm.addressLine1Error = false;
            vm.addressLine2Error = false;
            vm.addressCityError = false;
            vm.addressStateError = false;
            vm.addressPostcodeError = false;
            vm.phoneError = false;
            vm.secretQuestionError = false;
            vm.secretAnswerError = false;
            if (vm.data.accept == true) {
                vm.data.acceptRisk = 1;
            } else {
                vm.data.acceptRisk = 0;
            }
            if (_.isEmpty(vm.data.state)) {
                vm.data.state = "";
            }
            if (_.isEmpty(vm.data.addressLine2)) {
                vm.data.addressLine2 = "";
            }
            if (_.isEmpty(vm.data.addressPostcode)) {
                vm.data.addressPostcode = "";
            }
            if (!appStateService.hasMLT) {
                vm.data.birthDate = vm.data.userDateOfBirth.toISOString().slice(0, 10);
            }
            if (appStateService.hasMLT) {
                vm.data.birthDate = vm.data.dateOfBirth;
            }
            var params = {
                "salutation": vm.data.salutation,
                "first_name": vm.data.firstName,
                "last_name": vm.data.lastName,
                "date_of_birth": vm.data.birthDate,
                "residence": vm.countryParams.countryCode,
                "address_line_1": vm.data.addressLine1,
                "address_line_2": vm.data.addressLine2,
                "address_city": vm.data.addressCity,
                "address_state": vm.data.state,
                "address_postcode": vm.data.addressPostcode,
                "phone": vm.data.phone,
                "secret_question": vm.data.secretQuestion,
                "secret_answer": vm.data.secretAnswer,
                "forex_trading_experience": vm.data.forexTradingExperience,
                "forex_trading_frequency": vm.data.forexTradingFrequency,
                "indices_trading_experience": vm.data.indicesTradingExperience,
                "indices_trading_frequency": vm.data.indicesTradingFrequency,
                "commodities_trading_experience": vm.data.commoditiesTradingExperience,
                "commodities_trading_frequency": vm.data.commoditiesTradingFrequency,
                "stocks_trading_experience": vm.data.stocksTradingExperience,
                "stocks_trading_frequency": vm.data.stocksTradingFrequency,
                "other_derivatives_trading_experience": vm.data.otherDerivativesTradingExperience,
                "other_derivatives_trading_frequency": vm.data.otherDerivativesTradingFrequency,
                "other_instruments_trading_experience": vm.data.otherInstrumentsTradingExperience,
                "other_instruments_trading_frequency": vm.data.otherInstrumentsTradingFrequency,
                "employment_industry": vm.data.employmentIndustry,
                "education_level": vm.data.educationLevel,
                "income_source": vm.data.incomeSource,
                "net_income": vm.data.netIncome,
                "estimated_worth": vm.data.estimatedWorth,
                "accept_risk": vm.data.acceptRisk
            };
            websocketService.sendRequestFor.createMaltainvestAccountSend(params);
        };

        $scope.$on('new_account_maltainvest:error', function (e, error) {
            if (error.hasOwnProperty('details')) {
                $scope.$applyAsync(function () {

                    if (error.details.hasOwnProperty('salutation')) {
                        vm.salutationError = true;
                        vm.salutationErrorMessage = error.details.salutation;
                    }
                    if (error.details.hasOwnProperty('first_name')) {
                        vm.firstNameError = true;
                        vm.firstNameErrorMessage = error.details.first_name;
                    }
                    if (error.details.hasOwnProperty('last_name')) {
                        vm.lastNameError = true;
                        vm.lastNameErrorMessage = error.details.last_name;
                    }
                    if (error.details.hasOwnProperty('date_of_birth')) {
                        vm.dateOfBirthError = true;
                        vm.dateOfBirthErrorMessage = error.details.date_of_birth;
                    }
                    if (error.details.hasOwnProperty('residence')) {
                        vm.countryError = true;
                        vm.countryErrorMessage = error.details.residence;
                    }
                    if (error.details.hasOwnProperty('address_line_1')) {
                        vm.addressLine1Error = true;
                        vm.addressLine1ErrorMessage = error.details.address_line_1;
                    }
                    if (error.details.hasOwnProperty('address_line_2')) {
                        vm.addressLine2Error = true;
                        vm.addressLine2ErrorMessage = error.details.address_line_2;
                    }
                    if (error.details.hasOwnProperty('address_city')) {
                        vm.addressCityError = true;
                        vm.addressCityErrorMessage = error.details.address_city;
                    }
                    if (error.details.hasOwnProperty('address_state')) {
                        vm.addressStateError = true;
                        vm.addressStateErrorMessage = error.details.address_state;
                    }
                    if (error.details.hasOwnProperty('address_postcode')) {
                        vm.addressPostcodeError = true;
                        vm.addressPostcodeErrorMessage = error.details.address_postcode;
                    }
                    if (error.details.hasOwnProperty('phone')) {
                        vm.phoneError = true;
                        vm.phoneErrorMessage = error.details.phone;
                    }
                    if (error.details.hasOwnProperty('secret_question')) {
                        vm.secretQuestionError = true;
                        vm.secretQuestionErrorMessage = error.details.secret_question;
                    }
                    if (error.details.hasOwnProperty('secret_answer')) {
                        vm.secretAnswerError = true;
                        vm.secretAnswerErrorMessage = error.details.secret_answer;
                    }
                });
            }
            if (error.code) {
                alertService.displayError(error.message);
            }
        });

        $scope.$on('new_account_maltainvest', function (e, new_account_maltainvest) {
            websocketService.authenticate(new_account_maltainvest.oauth_token);
            vm.selectedAccount = new_account_maltainvest.oauth_token;
            appStateService.newAccountAdded = true;
            accountService.addedAccount = vm.selectedAccount;
        });
    }
})();
'use strict';

/**
 * @name new-account-real directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.new-real-account-opening.components.new-account-maltainvest').directive('bgNewAccountMaltainvest', NewAccountMaltainvest);

    function NewAccountMaltainvest() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/new-real-account-opening/components/new-account-maltainvest/new-account-maltainvest.template.html',
            controller: 'NewAccountMaltainvestController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name new-account-real controller
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.new-real-account-opening.components.new-account-real').controller('NewAccountRealController', NewAccountReal);

  NewAccountReal.$inject = ['$scope', '$state', '$rootScope', 'websocketService', 'appStateService', 'accountService', 'alertService'];

  function NewAccountReal($scope, $state, $rootScope, websocketService, appStateService, accountService, alertService) {
    var vm = this;
    vm.data = {};
    vm.salutationError = false;
    vm.firstNameError = false;
    vm.lastNameError = false;
    vm.dateOfBirthError = false;
    vm.countryError = false;
    vm.addressLine1Error = false;
    vm.addressLine2Error = false;
    vm.addressCityError = false;
    vm.addressStateError = false;
    vm.addressPostcodeError = false;
    vm.phoneError = false;
    vm.secretQuestionError = false;
    vm.secretAnswerError = false;

    vm.data.salutation = "Mr";
    vm.data.secretQuestion = "Mother's maiden name";
    vm.countryParams = JSON.parse(sessionStorage.countryParams);
    vm.data.countryCode = vm.countryParams.countryCode;
    $scope.$applyAsync(function () {
      vm.data.country = vm.countryParams.countryOfAccount;
    });

    websocketService.sendRequestFor.statesListSend(vm.data.countryCode);
    $scope.$on('states_list', function (e, states_list) {
      vm.data.statesList = states_list;
      vm.data.state = vm.data.statesList[0].value;
    });

    vm.findPhoneCode = function (country) {
      return country.value == vm.data.countryCode;
    };
    websocketService.sendRequestFor.residenceListSend();
    $scope.$on('residence_list', function (e, residence_list) {
      vm.residenceList = residence_list;
      vm.phoneCodeObj = vm.residenceList.find(vm.findPhoneCode);
      if (vm.phoneCodeObj.hasOwnProperty('phone_idd')) {
        vm.data.phone = '+' + vm.phoneCodeObj.phone_idd;
      }
    });

    vm.validateName = function (val) {
      var regex = /[`~!@#$%^&*)(_=+\[}{\]\\\/";:\?><,|\d]+/;
      return {
        test: function test(val) {
          var reg = regex.test(val);
          if (reg == true) {
            return false;
          } else {
            return true;
          }
        }
      };
    }();

    vm.submitAccountOpening = function () {
      vm.salutationError = false;
      vm.firstNameError = false;
      vm.lastNameError = false;
      vm.dateOfBirthError = false;
      vm.countryError = false;
      vm.addressLine1Error = false;
      vm.addressLine2Error = false;
      vm.addressCityError = false;
      vm.addressStateError = false;
      vm.addressPostcodeError = false;
      vm.phoneError = false;
      vm.secretQuestionError = false;
      vm.secretAnswerError = false;
      if (vm.data.dateOfBirth) {
        var birth = vm.data.dateOfBirth.toISOString().slice(0, 10);
      }
      if (_.isEmpty(vm.data.state)) {
        vm.data.state = "";
      }
      if (_.isEmpty(vm.data.addressLine2)) {
        vm.data.addressLine2 = "";
      }
      if (_.isEmpty(vm.data.addressPostcode)) {
        vm.data.addressPostcode = "";
      }
      var params = {
        "salutation": vm.data.salutation,
        "first_name": vm.data.firstName,
        "last_name": vm.data.lastName,
        "date_of_birth": birth,
        "residence": vm.data.countryCode,
        "address_line_1": vm.data.addressLine1,
        "address_line_2": vm.data.addressLine2,
        "address_city": vm.data.addressCity,
        "address_state": vm.data.state,
        "address_postcode": vm.data.addressPostcode,
        "phone": vm.data.phone,
        "secret_question": vm.data.secretQuestion,
        "secret_answer": vm.data.secretAnswer
      };
      websocketService.sendRequestFor.createRealAccountSend(params);
    };

    // error handling by backend errors under each input
    $scope.$on('new_account_real:error', function (e, error) {
      if (error.hasOwnProperty('details')) {
        $scope.$applyAsync(function () {
          if (error.details.hasOwnProperty('salutation')) {
            vm.salutationError = true;
            vm.salutationErrorMessage = error.details.salutation;
          }
          if (error.details.hasOwnProperty('first_name')) {
            vm.firstNameError = true;
            vm.firstNameErrorMessage = error.details.first_name;
          }
          if (error.details.hasOwnProperty('last_name')) {
            vm.lastNameError = true;
            vm.lastNameErrorMessage = error.details.last_name;
          }
          if (error.details.hasOwnProperty('date_of_birth')) {
            vm.dateOfBirthError = true;
            vm.dateOfBirthErrorMessage = error.details.date_of_birth;
          }
          if (error.details.hasOwnProperty('residence')) {
            vm.countryError = true;
            vm.countryErrorMessage = error.details.residence;
          }
          if (error.details.hasOwnProperty('address_line_1')) {
            vm.addressLine1Error = true;
            vm.addressLine1ErrorMessage = error.details.address_line_1;
          }
          if (error.details.hasOwnProperty('address_line_2')) {
            vm.addressLine2Error = true;
            vm.addressLine2ErrorMessage = error.details.address_line_2;
          }
          if (error.details.hasOwnProperty('address_city')) {
            vm.addressCityError = true;
            vm.addressCityErrorMessage = error.details.address_city;
          }
          if (error.details.hasOwnProperty('address_state')) {
            vm.addressStateError = true;
            vm.addressStateErrorMessage = error.details.address_state;
          }
          if (error.details.hasOwnProperty('address_postcode')) {
            vm.addressPostcodeError = true;
            vm.addressPostcodeErrorMessage = error.details.address_postcode;
          }
          if (error.details.hasOwnProperty('phone')) {
            vm.phoneError = true;
            vm.phoneErrorMessage = error.details.phone;
          }
          if (error.details.hasOwnProperty('secret_question')) {
            vm.secretQuestionError = true;
            vm.secretQuestionErrorMessage = error.details.secret_question;
          }
          if (error.details.hasOwnProperty('secret_answer')) {
            vm.secretAnswerError = true;
            vm.secretAnswerErrorMessage = error.details.secret_answer;
          }
        });
      }
      if (error.code) {
        alertService.displayError(error.message);
      }
    });

    $scope.$on('new_account_real', function (e, new_account_real) {
      websocketService.authenticate(new_account_real.oauth_token);
      vm.selectedAccount = new_account_real.oauth_token;
      appStateService.newAccountAdded = true;
      accountService.addedAccount = vm.selectedAccount;
    });
  }
})();
'use strict';

/**
 * @name new-account-real directive
 * @author Nazanin Reihani Haghighi
 * @contributors []
 * @since 08/14/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.new-real-account-opening.components.new-account-real').directive('bgNewAccountReal', NewAccountReal);

    function NewAccountReal() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/new-real-account-opening/components/new-account-real/new-account-real.template.html',
            controller: 'NewAccountRealController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {}

        };
        return directive;
    }
})();
'use strict';

/**
 * @name Oauth Controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/13/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.signin.components.oauth').controller('OauthController', Oauth);

  Oauth.$inject = ['$scope', '$ionicLoading', 'config', 'websocketService', 'alertService', 'accountService', 'languageService'];

  function Oauth($scope, $ionicLoading, config, websocketService, alertService, accountService, languageService) {

    var vm = this;

    var accounts = [];

    var authenticate = function authenticate(_token) {
      // Validate the token
      if (_token && _token.length == 32) {
        $ionicLoading.show();
        websocketService.authenticate(_token);
      } else {
        alertService.accountError.tokenNotValid();
      }
    };

    window.onmessage = function (_message) {
      if (_message.data && _message.data.url) {
        accounts = getAccountsFromUrl(_message.data.url);
        if (accounts.length > 0) {
          authenticate(accounts[0].token);
        }
      }
    };

    $scope.$on('authorize', function (e, response) {
      if (response) {
        for (var a in accounts) {
          if (a == 0) {
            continue;
          }

          accounts[a].email = response.email;
          accountService.add(accounts[a]);
        }
      }
      $ionicLoading.hide();
    });

    vm.signin = function () {
      var authWindow = window.open(config.oauthUrl + '?app_id=' + config.app_id + '&l=' + languageService.read(), "_blank", "location=no,toolbar=no");

      $(authWindow).on('loadstart', function (e) {
        var url = e.originalEvent.url;

        if (getErrorFromUrl(url).length > 0) {
          authWindow.close();
          return;
        }

        accounts = getAccountsFromUrl(url);
        if (accounts && accounts.length) {
          authWindow.close();

          authenticate(accounts[0].token);
        }
      });
    };

    function getAccountsFromUrl(_url) {
      var regex = /acct\d+=(\w+)&token\d+=(\w{2}-\w{29})/g;
      var result = null;
      var accounts = [];

      while (result = regex.exec(_url)) {
        accounts.push({
          loginid: result[1],
          token: result[2],
          email: "",
          is_default: false
        });
      }

      return accounts;
    }

    function getErrorFromUrl(_url) {
      var regex = /error=(\w+)/g;
      var result = null;
      var error = [];

      while (result = regex.exec(_url)) {
        error.push(result[1]);
      }

      return error;
    }
  }
})();
'use strict';

/**
 * @name Oauth directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 8/13/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.signin.components.oauth').directive('oauth', Oauth);

  function Oauth() {
    var directive = {
      restrict: 'E',
      scope: {},
      templateUrl: 'js/pages/sign-in/components/oauth/oauth.template.html',
      controller: "OauthController",
      controllerAs: "vm",
      bindToController: true
    };

    return directive;
  }
})();
'use strict';

/**
 * @name chart controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 08/29/2015
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.chart.controllers').controller('ChartController', Chart);

    Chart.$inject = ['$scope', 'chartService', 'websocketService'];

    function Chart($scope, chartService, websocketService) {

        var vm = this;

        $scope.$on('$destroy', function (e, value) {
            chartService.destroy();
        });

        $scope.$on('portfolio', function (e, portfolio) {
            var contractId = vm.purchasedContract.contractId;

            if (!_.isEmpty(contractId)) {
                portfolio.contracts.forEach(function (contract) {
                    if (contract.contract_id == contractId) {
                        chartService.addContract({
                            startTime: contract.date_start + 1,
                            duration: parseInt(vm.proposal.duration),
                            type: vm.proposal.tradeType === "Higher/Lower" ? contract.contract_type + 'HL' : contract.contract_type,
                            barrier: vm.proposal.barrier
                        });
                    }
                });
            }
        });

        $scope.$on('tick', function (e, feed) {
            if (feed && feed.echo_req.ticks_history === vm.proposal.symbol) {
                chartService.historyInterface.addTick(feed.tick);
            } else {
                websocketService.sendRequestFor.forgetStream(feed.tick.id);
            }
        });

        $scope.$on('history', function (e, feed) {
            if (feed && feed.echo_req.ticks_history === vm.proposal.symbol) {
                chartService.historyInterface.addHistory(feed.history);
            }
        });

        $scope.$on('candles', function (e, feed) {
            if (feed) {
                chartService.historyInterface.addCandles(feed.candles);
            }
        });

        $scope.$on('ohlc', function (e, feed) {
            if (feed) {
                chartService.historyInterface.addOhlc(feed.ohlc);
            }
        });

        $scope.$on('connection:ready', function (e) {
            sendTickHistoryRequest();
        });

        $scope.$watch(function () {
            return vm.proposal.symbol;
        }, function (newValue, oldValue) {
            if (vm.proposal.symbol) {
                //&& newValue !== oldValue){
                sendTickHistoryRequest();
            }
        });

        function init() {
            var chartId = 'tradeChart';

            vm.chartDragLeft = chartService.dragLeft;
            vm.chartDragRight = chartService.dragRight;
            vm.chartTouch = chartService.dragStart;
            vm.chartRelease = chartService.dragEnd;
            vm.chartPinchIn = chartService.zoomOut;
            vm.chartPinchOut = chartService.zoomIn;
            vm.chartPinchStart = chartService.zoomStart;
            vm.chartPinchEnd = chartService.zoomEnd;

            chartService.drawChart(chartId);
            sendTickHistoryRequest();
        }

        function sendTickHistoryRequest() {
            if (_.isEmpty(vm.proposal.symbol)) {
                return;
            }

            var symbol = vm.proposal.symbol;
            websocketService.sendRequestFor.forgetTicks();
            websocketService.sendRequestFor.ticksHistory({
                ticks_history: symbol,
                end: 'latest',
                count: chartService.getCapacity(),
                subscribe: 1
            });
        }

        init();
    }
})();
'use strict';

/**
 * @name chart directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 08/29/2015
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.chart.directives').directive('bgChart', Chart);

    function Chart() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/trade/components/chart/chart.template.html',
            controller: 'ChartController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {
                proposal: '=',
                purchasedContract: '='
            }
        };

        return directive;
    }
})();
'use strict';

/**
 * @name digit-result controller
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/01/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.chart.controllers').controller('DigitResultController', Result);

  Result.$inject = ['$scope', 'chartService'];

  function Result($scope, chartService) {
    var vm = this;

    vm.spots = [];
    vm.reset = true;
    vm.counter = 0;

    $scope.$on('contract:spot', function (e, contract, lastPrice) {
      if (vm.reset) {
        vm.spots = new Array(contract.duration + 1).fill().map(function (e, i) {
          return {};
        });
        vm.reset = false;
        vm.counter = 0;
      }

      var localContract = _.clone(contract);

      $scope.$applyAsync(function () {
        vm.spots[vm.counter++] = {
          result: localContract.result,
          value: lastPrice.toString().slice(-1)
        };
      });
    });

    $scope.$on('contract:finished', function (e, contract) {
      vm.reset = true;
    });
  }
})();
'use strict';

/**
 * @name digit-result directive
 * @author Morteza Tavanarad
 * @contributors []
 * @since 10/01/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.chart.directives').directive('bgDigitResult', Result);

  function Result() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/pages/trade/components/chart/digit-result.template.html',
      controller: 'DigitResultController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {}
    };

    return directive;
  }
})();
'use strict';

/**
 * @name longcode controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/27/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.longcode.controllers').controller('LongcodeController', Longcode);

  function Longcode() {
    var vm = this;
  }
})();
'use strict';

/**
 * @name longcode direciive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/27/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.longcode.directives').directive('bgLongcode', Longcode);

  function Longcode() {
    var direciive = {
      restrict: 'E',
      templateUrl: 'js/pages/trade/components/longcode/longcode.template.html',
      controller: 'LongcodeController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {
        purchasedContract: '='
      }
    };

    return direciive;
  }
})();
'use strict';

/**
 * @name barrier controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/19/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options.controllers').controller('BarrierController', Barrier);

  Barrier.$inject = [];

  function Barrier() {
    var vm = this;
    var pattern = /^[\+-]\d+(\.\d{1,5})?|\d+(\.\d{1,5})?/;
  }
})();
'use strict';

/**
 * @name barrier directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/19/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options.directives').directive('bgBarrier', Barrier);

  function Barrier() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/pages/trade/components/options/barrier.template.html',
      controller: 'BarrierController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {
        proposal: '='
      }
    };

    return directive;
  }
})();
'use strict';

/**
 * @name digits controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.controllers').controller('DigitsController', Digits);

    Digits.$inject = [];

    function Digits() {
        var vm = this;

        vm.digits = [];

        vm.selectDigit = function (digit) {
            vm.select()(digit);
        };

        function init() {
            var tradeTypes = JSON.parse(sessionStorage.tradeTypes)[vm.tradeType];
            vm.digits = _.union(tradeTypes[0].last_digit_range, tradeTypes[1].last_digit_range);
        }

        init();
    }
})();
'use strict';

/**
 * @name digits directvie
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.directives').directive('bgDigits', Digits);

    function Digits() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/trade/components/options/digits.template.html',
            controller: 'DigitsController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {
                select: '&',
                tradeType: '='
            }
        };

        return directive;
    }
})();
'use strict';

/**
 * @name markets controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/20/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options.controllers').controller('MarketsController', Markets);

  Markets.$inject = ['$scope', 'marketsService', 'websocketService'];

  function Markets($scope, marketsService, websocketService) {
    var vm = this;
    vm.markets = {};

    function init() {
      if (_.isEmpty(sessionStorage.markets)) {
        setTimeout(init, 500);
        return;
      }

      $scope.$applyAsync(function () {
        vm.markets = JSON.parse(sessionStorage.markets);
      });
    }

    vm.selectMarket = function (market) {
      vm.select()(market);
    };

    init();
  }
})();
'use strict';

/**
 * @name markets directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/20/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options.directives').directive('bgMarkets', Markets);

  function Markets() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/pages/trade/components/options/markets.template.html',
      controller: 'MarketsController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {
        select: "&"
      }
    };

    return directive;
  }
})();
'use strict';

/**
 * @name markets controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/20/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options.services').factory('marketsService', Markets);

  Markets.$inject = [];

  function Markets() {
    var factory = {};
    var assetIndex = [];

    var ASSETINDEXES = {
      symbol: 0,
      displayName: 1,
      contracts: 2,
      contractName: 0,
      contractDisplayName: 1,
      contractFrom: 2,
      contractTo: 3
    };

    factory.getMarketByIndex = function (index) {
      if (!_.isEmpty(sessionStorage.markets)) {
        var markets = JSON.parse(sessionStorage.markets);
        var keys = Object.keys(markets);
        return markets[keys[index]];
      }
      return null;
    };

    factory.findTickMarkets = function () {
      var activeSymbols = JSON.parse(sessionStorage.active_symbols);
      assetIndex = JSON.parse(sessionStorage.asset_index);

      var markets = {};

      _.forEach(activeSymbols, function (value, key) {
        var underlying = [];

        for (var i in value) {
          if (isSupportTick(value[i].symbol)) {
            underlying.push(value[i]);
          }
        }

        if (underlying.length > 0) {
          markets[key] = {
            displayName: value[0].market_display_name,
            underlying: underlying
          };
        }
      });

      sessionStorage.markets = JSON.stringify(markets);

      return markets;
    };

    function isSupportTick(symbol) {
      var symbolIndex = _.findIndex(assetIndex, function (value) {
        return value[ASSETINDEXES.symbol] === symbol;
      });

      if (symbolIndex > -1) {
        var tickUnderlying = _.findIndex(assetIndex[symbolIndex][ASSETINDEXES.contracts], function (value) {
          return value[ASSETINDEXES.contractFrom].indexOf('t') > -1;
        });

        return tickUnderlying > -1;
      }

      return false;
    }

    return factory;
  }
})();
'use strict';

/**
 * @name options controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.controllers').controller('OptionsController', Options);

    Options.$inject = ['$scope', '$ionicModal', 'marketsService', 'optionsService', 'proposalService', 'tradeService', 'tradeTypesService', 'websocketService'];

    function Options($scope, $ionicModal, marketsService, optionsService, proposalService, tradeService, tradeTypesService, websocketService) {
        var vm = this;

        vm.showOptions = false;
        vm.marketsClosed = false;

        vm.SECTIONS = {
            OVERVIEW1: 0,
            OVERVIEW2: 1,
            UNDERLYINGS: 2,
            MARKETS: 3,
            TRADETYPES: 4,
            TICKS: 5,
            DIGITS: 6
        };

        vm.options = {
            market: null,
            underlying: null,
            tradeType: null,
            tick: null,
            digit: null
        };

        vm.section1 = vm.SECTIONS.OVERVIEW1; //vm.options.market ? vm.SECTIONS.OVERVIEW : vm.SECTIONS.MARKETS;
        vm.section2 = vm.SECTIONS.OVERVIEW2;

        $scope.$on('symbols:updated', function (e, openMarkets) {
            if (_.isEmpty(openMarkets)) {
                vm.showOptions = false;
                vm.marketsClosed = true;
                vm.proposal = {};
            } else {
                vm.showOptions = true;
                websocketService.sendRequestFor.assetIndex();
            }
        });

        $scope.$on('assetIndex:updated', function (e) {
            var markets = marketsService.findTickMarkets();
            if (!_.isEmpty(vm.options.market) && _.find(markets, ['displayName', vm.options.market.displayName])) {
                vm.selectMarket(vm.options.market);
            } else {
                vm.selectMarket(marketsService.getMarketByIndex(0));
            }
        });

        $scope.$on('symbol', function (e, groupSymbols) {
            sessionStorage.groupSymbols = JSON.stringify(groupSymbols);
            var tradeTypes = tradeTypesService.findTickContracts(groupSymbols);
            $scope.$applyAsync(function () {
                vm.options.tradeType = Object.keys(tradeTypes).indexOf(vm.options.tradeType) > -1 ? vm.options.tradeType || Object.keys(tradeTypes)[0] : Object.keys(tradeTypes)[0];
                vm.options.tick = vm.options.tick || tradeTypes[vm.options.tradeType][0].min_contract_duration.slice(0, -1);
                vm.options.digit = tradeTypes[vm.options.tradeType][0].last_digit_range ? vm.options.digit || tradeTypes[vm.options.tradeType][0].last_digit_range[0] : null;
                vm.options.barrier = tradeTypes[vm.options.tradeType][0].barriers > 0 ? vm.options.barrier || tradeTypes[vm.options.tradeType][0].barrier : null;
                updateProposal();
                tradeService.proposalIsReady = true;
            });
        });

        $scope.$on('authorize', function (e, response) {
            vm.proposal.currency = response.currency;
        });

        $scope.$on('options:updated', function (e, options) {
            vm.options = options;
        });

        $ionicModal.fromTemplateUrl('js/pages/trade/components/options/options-modal.html', {
            scope: $scope
        }).then(function (modal) {
            vm.modalCtrl = modal;
        });

        vm.closeModal = function () {
            vm.section1 = vm.SECTIONS.OVERVIEW1;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            hideModal();
        };

        vm.setSection = function (id, section) {
            switch (section) {
                case vm.SECTIONS.MARKETS:
                    var markets = JSON.parse(sessionStorage.markets || '{}');
                    if (Object.keys(markets).length <= 1) {
                        return;
                    }
                    break;
                case vm.SECTIONS.UNDERLYINGS:
                    if (vm.options.market.underlying.length <= 1) {
                        return;
                    }
                    break;
                case vm.SECTIONS.TRADETYPES:
                    var tradeTypes = JSON.parse(sessionStorage.tradeTypes || '{}');
                    if (Object.keys(tradeTypes).length <= 1) {
                        return;
                    }
                    break;
            }

            if (id == 1) {
                vm.section2 = vm.SECTIONS.OVERVIEW2;
                vm.section1 = section;
            } else if (id == 2) {
                vm.section1 = vm.SECTIONS.OVERVIEW1;
                vm.section2 = section;
            }

            vm.modalCtrl.show();
        };

        vm.selectMarket = function (market) {
            vm.options.market = market;
            vm.options.underlying = !_.isEmpty(vm.options.underlying) && _.findIndex(market.underlying, ['symbol', vm.options.underlying.symbol]) > -1 ? vm.options.underlying : market.underlying[0];
            websocketService.sendRequestFor.contractsForSymbol(vm.options.underlying.symbol);
            vm.section1 = vm.SECTIONS.OVERVIEW1;
            updateProposal();
            hideModal();
        };

        vm.selectUnderlying = function (underlying) {
            vm.options.underlying = underlying;
            websocketService.sendRequestFor.contractsForSymbol(underlying.symbol);
            vm.section1 = vm.SECTIONS.OVERVIEW1;
            updateProposal();
            hideModal();
        };

        vm.selectTradeType = function (tradeType) {
            vm.options.tradeType = tradeType;
            var tradeType = JSON.parse(sessionStorage.tradeTypes)[tradeType][0];
            vm.options.tick = vm.options.tick || tradeType.min_contract_duration.slice(0, -1);
            vm.options.digit = tradeType.last_digit_range ? vm.options.digit || tradeType.last_digit_range[0] : null;
            vm.options.barrier = tradeType.barriers > 0 && !_.isEmpty(tradeType.barrier) ? vm.options.barrier || tradeType.barrier : null;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            updateProposal();
            hideModal();
        };

        vm.selectTick = function (tick) {
            vm.options.tick = tick;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            updateProposal();
            hideModal();
        };

        vm.selectDigit = function (digit) {
            vm.options.digit = digit;
            vm.options.barrier = null;
            vm.section2 = vm.SECTIONS.OVERVIEW2;
            updateProposal();
            hideModal();
        };

        function init() {
            var options = optionsService.get();
            if (!_.isEmpty(options)) {
                vm.options = options;
                //vm.selectMarket(vm.options.market);
                updateProposal();
            }
            websocketService.sendRequestFor.symbols();
        }

        function updateProposal() {
            $scope.$applyAsync(function () {
                vm.proposal = proposalService.update(vm.options);
            });
        }

        function hideModal() {
            if (vm.modalCtrl) {
                vm.modalCtrl.hide();
            }
        }

        init();
    }
})();
'use strict';

/**
 * @name options directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/21/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options.directives').directive('bgOptions', Options);

  function Options() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/pages/trade/components/options/options.template.html',
      controller: 'OptionsController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {
        proposal: '='
      }
    };

    return directive;
  }
})();
'use strict';

/**
 * @name options service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/31/2016
 * @copyright Binary Ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.options.services').factory('optionsService', Options);

  function Options() {
    var factory = {};

    factory.get = function () {
      if (_.isEmpty(localStorage.options)) {
        return null;
      }

      return JSON.parse(localStorage.options);
    };

    factory.set = function (options) {
      if (!_.isEmpty(options)) {
        localStorage.options = JSON.stringify(options);
        return true;
      }

      return false;
    };

    return factory;
  }
})();
'use strict';

/**
 * @name ticks directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.controllers').controller('TicksController', Ticks);

    Ticks.$inject = [];

    function Ticks() {
        var vm = this;

        vm.min = 0;
        vm.max = 0;
        vm.tickRange = [];

        vm.selectTick = function (tick) {
            vm.select()(tick);
        };

        function init() {
            var tradeType = JSON.parse(sessionStorage.tradeTypes)[vm.tradeType][0];
            vm.min = Number.parseInt(getTickValue(tradeType.min_contract_duration));
            vm.max = Number.parseInt(getTickValue(tradeType.max_contract_duration));

            vm.tickRange = _.range(vm.min, vm.max + 1);
        }

        function getTickValue(tick) {
            return tick.slice(0, -1);
        }

        init();
    }
})();
'use strict';

/**
 * @name ticks directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/26/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.directives').directive('bgTicks', Ticks);

    function Ticks() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/trade/components/options/ticks.template.html',
            controller: 'TicksController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {
                select: '&',
                tradeType: '='
            }
        };

        return directive;
    }
})();
'use strict';

/**
 * @name trayeTypes directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/24/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.controllers').controller('TradeTypesController', TradeTypes);

    TradeTypes.$inject = [];

    function TradeTypes() {
        var vm = this;

        vm.tradeTypes = {};

        vm.selectTradeType = function (tradeType) {
            vm.select()(tradeType);
        };

        function init() {
            vm.tradeTypes = JSON.parse(sessionStorage.tradeTypes);
        }

        init();
    }
})();
'use strict';

/**
 * @name trayeTypes directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/24/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.directives').directive('bgTradetypes', TradeTypes);

    function TradeTypes() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/trade/components/options/trade-types.template.html',
            controller: 'TradeTypesController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {
                select: "&"
            }
        };

        return directive;
    }
})();
'use strict';

/**
 * @name trayeTypes service
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/24/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.services').factory('tradeTypesService', TradeTypes);

    function TradeTypes() {
        var directive = {};

        directive.findTickContracts = function (contracts) {
            var tradeTypes = {};
            _.forEach(contracts, function (value, key) {
                var contracts = [];

                for (var i in value) {
                    if (value[i].expiry_type === 'tick') {
                        contracts.push(value[i]);
                    }
                }

                if (contracts.length > 0) {
                    tradeTypes[key] = contracts;
                }
            });

            var groupedTradeTypes = {};
            _.forEach(tradeTypes, function (value, key) {
                if (value.length == 2) {
                    groupedTradeTypes[value[0].contract_category_display] = value;
                } else {
                    for (var i = 0; i < value.length; i = i + 2) {
                        var name = value[i].contract_category_display;
                        if (value[i].contract_category === 'callput') {
                            if (_.isEmpty(value[i].barrier)) {
                                name = "Rise/Fall";
                            } else {
                                name = "Higher/Lower";
                            }
                        } else {
                            name += " " + value[i].contract_display.capitalize() + "/" + value[i + 1].contract_display.capitalize();
                        }

                        groupedTradeTypes[name] = [value[i], value[i + 1]];
                    }
                }
            });

            sessionStorage.tradeTypes = JSON.stringify(groupedTradeTypes);
            return groupedTradeTypes;
        };

        return directive;
    }
})();
'use strict';

/**
 * @name underlyings controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/25/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.controllers').controller('UnderlyingsController', Underlying);

    Underlying.$inject = [];

    function Underlying() {
        var vm = this;
        vm.underlyings = [];

        vm.selectUnderlying = function (underlying) {
            vm.select()(underlying);
        };

        function init() {
            vm.underlyings = vm.market.underlying;
        }

        init();
    }
})();
'use strict';

/**
 * @name underlyings directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/25/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.options.directives').directive('bgUnderlyings', Underlying);

    function Underlying() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/trade/components/options/underlyings.template.html',
            controller: 'UnderlyingsController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {
                market: '=',
                select: '&'
            }
        };

        return directive;
    }
})();
'use strict';

/**
 * @name payout controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.payout.controllers').controller('PayoutController', Payout);

    Payout.$inject = ['$scope', 'proposalService'];

    function Payout($scope, proposalService) {
        var vm = this;
        vm.amount = vm.proposal.amount;

        $scope.$watch(function () {
            return vm.proposal.amount;
        }, function (newVal, oldVal) {
            if (newVal != vm.amount) {
                vm.amount = newVal;
            }
        });

        vm.changePayoutType = function () {
            if (vm.proposal.basis === "payout") {
                vm.proposal.basis = "stake";
            } else {
                vm.proposal.basis = "payout";
            }
            proposalService.setPropertyValue('basis', vm.proposal.basis);
        };

        vm.changeAmount = function () {
            if (_.isEmpty(vm.amount) || vm.amount === 'NaN' || Number(vm.amount) == 0) {
                vm.proposal.amount = 0;
            } else {
                vm.proposal.amount = vm.amount;
            }
            proposalService.setPropertyValue('amount', vm.proposal.amount);
        };

        vm.add = function () {
            vm.amount = Number(vm.amount) + 1 <= 10000 ? Number(vm.amount) + 1 : 100000;
        };

        vm.subtract = function () {
            vm.amount = Number(vm.amount) - 1 >= 1 ? Number(vm.amount) - 1 : 1;
        };

        vm.stopLongPress = function () {
            vm.proposal.amount = vm.amount;
            proposalService.setPropertyValue('amount', vm.proposal.amount);
        };

        function init() {}

        init();
    }
})();
'use strict';

/**
 * @name payout directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright Binary Ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.payout.directives').directive('bgPayout', Payout);

    function Payout() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/trade/components/payout/payout.template.html',
            controller: 'PayoutController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {
                proposal: '='
            }
        };

        return directive;
    }
})();
'use strict';

/**
 * @name contract-summary controller
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/07/2016
 * @copyright binary ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.purchase.controllers').controller('ContractSummaryController', Summary);

  Summary.$inject = [];

  function Summary() {
    var vm = this;
  }
})();
'use strict';

/**
 * @name contract-summary directive
 * @author Morteza Tavnarad
 * @contributors []
 * @since 09/07/2016
 * @copyright binary ltd
 */

(function () {
  'use strict';

  angular.module('binary.pages.trade.components.purchase.directives').directive('bgContractSummary', Summary);

  function Summary() {
    var directive = {
      restrict: 'E',
      templateUrl: 'js/pages/trade/components/purchase/contract-summary.template.html',
      controller: 'ContractSummaryController',
      controllerAs: 'vm',
      bindToController: true,
      scope: {
        proposal: '=',
        purchasedContract: '='
      }
    };

    return directive;
  }
})();
'use strict';

/**
 * @name purchase controller
 * @author morteza tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright binary ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.purchase.controllers').controller('PurchaseController', Purchase);

    Purchase.$inject = ['$scope', '$timeout', 'analyticsService', 'accountService', 'appStateService', 'proposalService', 'tradeService', 'websocketService'];

    function Purchase($scope, $timeout, analyticsService, accountService, appStateService, proposalService, tradeService, websocketService) {
        var vm = this;

        vm.contracts = [];
        vm.proposalResponses = [];
        vm.inPurchaseMode = false;
        vm.showSummary = false;
        vm.purchasedContractIndex = -1;

        $scope.$watch(function () {
            return vm.proposal;
        }, function (newValue, oldValue) {
            proposalUpdated();
        }, true);

        $scope.$on('appState:tradeMode', function (e) {
            vm.showSummary = !appStateService.tradeMode;
        });

        $scope.$on('proposal', function (e, proposal, reqId) {
            if ([1, 2].indexOf(reqId) > -1) {
                $scope.$applyAsync(function () {
                    vm.proposalResponses[reqId - 1] = proposal;
                    vm.proposalResponses[reqId - 1].hasError = false;
                });
            }
        });

        $scope.$on('proposal:error', function (e, error, reqId) {

            if ([1, 2].indexOf(reqId) > -1) {
                $scope.$applyAsync(function () {
                    vm.proposalResponses[reqId - 1] = error;
                    vm.proposalResponses[reqId - 1].hasError = true;
                });
                $timeout(vm.autoSizeText, 1000);
            }
        });

        $scope.$on('purchase', function (e, response) {
            if (!_.isEmpty(response.buy)) {
                vm.showSummary = true;
                $scope.$applyAsync(function () {
                    vm.purchasedContract = {
                        contractId: response.buy.contract_id,
                        longcode: response.buy.longcode,
                        payout: vm.proposalResponses[vm.purchasedContractIndex].payout,
                        cost: response.buy.buy_price,
                        profit: parseFloat(vm.proposalResponses[vm.purchasedContractIndex].payout) - parseFloat(response.buy.buy_price),
                        balance: response.buy.balance_after,
                        transactionId: response.buy.transaction_id
                    };
                });
                websocketService.sendRequestFor.portfolio();
            }
        });

        $scope.$on('purchase:error', function (e, error) {
            vm.inPurchaseMode = false;
            vm.showSummary = false;
            appStateService.tradeMode = true;
            appStateService.purchaseMode = false;
            vm.purchasedContractIndex = -1;
            sendProposal();
        });

        $scope.$on('contract:finished', function (e, contract) {

            if (contract.exitSpot) {
                if (contract.result === "win") {
                    vm.purchasedContract.buyPrice = vm.purchasedContract.cost;
                    vm.purchasedContract.profit = vm.purchasedContract.profit;
                    vm.purchasedContract.finalPrice = vm.purchasedContract.buyPrice + vm.purchasedContract.profit;
                    websocketService.sendRequestFor.openContract();
                } else if (contract.result === "lose") {
                    vm.purchasedContract.buyPrice = vm.purchasedContract.cost;
                    vm.purchasedContract.loss = vm.purchasedContract.cost;
                    vm.purchasedContract.finalPrice = vm.purchasedContract.buyPrice + vm.purchasedContract.loss;
                }
                vm.purchasedContract.result = contract.result === 'lose' ? 'loss' : contract.result;

                var proposal = vm.contracts[vm.purchasedContractIndex];

                // Send statistic to Google Analytics
                analyticsService.google.trackEvent(proposal.market, proposal.contract_type, proposal.underlying_symbol, vm.purchasedContract.payout);

                var ampEventProperties = {
                    Symbol: proposal.underlying_symbol,
                    TradeType: proposal.contract_type,
                    Stake: vm.purchasedContract.buyPrice,
                    Market: proposal.market,
                    Duration: vm.proposal.duration,
                    DurationUnit: vm.proposal.duration_unit,
                    result: contract.result === "lose" ? "Lost" : "Won"
                };
                // Send statistic to Amplitude
                analyticsService.amplitude.logEvent("Purchase", ampEventProperties);

                sendProposal();

                // Unlock view to navigate
                vm.inPurchaseMode = false;
                appStateService.purchaseMode = false;
            }
        });

        vm.getImageUrl = function (contractType) {
            return "img/trade-icon/" + contractType.toLowerCase() + ".svg";
        };

        vm.purchase = function (contractIndex) {
            $scope.$applyAsync(function () {
                vm.inPurchaseMode = true;
                vm.purchasedContractIndex = contractIndex;
                appStateService.purchaseMode = true;
                appStateService.tradeMode = false;
            });
            proposalService.purchase(vm.proposalResponses[contractIndex]);
        };

        vm.backToTrade = function () {
            vm.showSummary = false;
            appStateService.tradeMode = true;
            appStateService.purchaseMode = false;
            vm.purchasedContractIndex = -1;
        };

        function init() {
            vm.user = accountService.getDefault();
            if (_.isEmpty(vm.contracts)) {
                setTimeout(init, 500);
                return;
            }
            //sendProposal();
        }

        function sendProposal() {

            proposalService.forget();

            var proposal1 = _.clone(vm.proposal);
            proposal1.contract_type = vm.contracts[0].contract_type;
            proposal1.req_id = 1;

            var proposal2 = _.clone(vm.proposal);
            proposal2.contract_type = vm.contracts[1].contract_type;
            proposal2.req_id = 2;

            proposalService.send(proposal1);
            proposalService.send(proposal2);
        }

        function proposalUpdated() {
            if (!_.isEmpty(sessionStorage.tradeTypes)) {
                var tradeTypes = JSON.parse(sessionStorage.tradeTypes);
                vm.contracts = tradeTypes[vm.proposal.tradeType];

                if (!_.isEmpty(vm.contracts)) {
                    sendProposal();
                }
            } else {
                setTimeout(proposalUpdated, 5);
            }
        }

        vm.autoSizeText = function () {
            var el, elements, _i, _len, _results;
            elements = document.getElementsByClassName('resize');
            if (elements.length < 0) {
                return;
            }
            _results = [];
            for (_i = 0, _len = elements.length; _i < _len; _i++) {
                el = elements[_i];
                _results.push(function (el) {
                    var resizeText, _results1;
                    resizeText = function resizeText() {
                        var elNewFontSize;
                        elNewFontSize = parseInt($(el).css('font-size').slice(0, -2)) - 1 + 'px';
                        return $(el).css('font-size', elNewFontSize);
                    };
                    _results1 = [];
                    while (el.scrollHeight > el.offsetHeight) {
                        _results1.push(resizeText());
                    }
                    return _results1;
                }(el));
            }
            return _results;
        };

        init();
    }
})();
'use strict';

/**
 * @name purchase directive
 * @author morteza tavnarad
 * @contributors []
 * @since 08/27/2016
 * @copyright binary ltd
 */

(function () {
    'use strict';

    angular.module('binary.pages.trade.components.purchase.directives').directive('bgPurchase', Purchase);

    function Purchase() {
        var directive = {
            restrict: 'E',
            templateUrl: 'js/pages/trade/components/purchase/purchase.template.html',
            controller: 'PurchaseController',
            controllerAs: 'vm',
            bindToController: true,
            scope: {
                proposal: '=',
                purchasedContract: '=',
                showSummary: '=inPurchaseMode'
            }
        };

        return directive;
    }
})();
'use strict';

angular.module('binary').controller('BodyController', ["$scope", "languageService", function ($scope, languageService) {
    var vm = this;
    vm.getLanguage = function () {
        return languageService.read();
    };
}]);